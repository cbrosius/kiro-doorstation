<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>ESP32 SIP Door Station</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
        }

        .container {
            max-width: 800px;
            margin: auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        h1,
        h2 {
            color: #333;
        }

        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .status-card {
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #ddd;
        }

        .status-card h3 {
            margin-top: 0;
            margin-bottom: 10px;
        }

        .status.connected {
            background-color: #e7f5e7;
            border-color: #4caf50;
            color: #4caf50;
        }

        .status.disconnected {
            background-color: #fdecea;
            border-color: #f44336;
            color: #f44336;
        }

        .status.connecting {
            background-color: #fff3cd;
            border-color: #ffc107;
            color: #856404;
        }

        .status.warning {
            background-color: #d1ecf1;
            border-color: #17a2b8;
            color: #0c5460;
        }

        .status.error {
            background-color: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }

        .form-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        form {
            display: flex;
            flex-direction: column;
        }

        label {
            margin-bottom: 5px;
            font-weight: bold;
        }

        input[type="text"],
        input[type="password"],
        select {
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px 0;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        button.secondary {
            background-color: #6c757d;
        }

        button.secondary:hover {
            background-color: #5a6268;
        }

        button.danger {
            background-color: #dc3545;
        }

        button.danger:hover {
            background-color: #c82333;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        .wifi-networks {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .wifi-network {
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .wifi-network:hover {
            background-color: #f8f9fa;
        }

        .wifi-network.selected {
            background-color: #e3f2fd;
        }

        .signal-strength {
            font-size: 12px;
            color: #666;
        }

        .toast {
            visibility: hidden;
            min-width: 250px;
            margin-left: -125px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 2px;
            padding: 16px;
            position: fixed;
            z-index: 1;
            left: 50%;
            bottom: 30px;
        }

        .toast.show {
            visibility: visible;
            -webkit-animation: fadein 0.5s, fadeout 0.5s 2.5s;
            animation: fadein 0.5s, fadeout 0.5s 2.5s;
        }

        .toast.success {
            background-color: #28a745;
        }

        .toast.error {
            background-color: #dc3545;
        }

        .toast.info {
            background-color: #17a2b8;
        }

        .system-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 14px;
        }

        .system-info div {
            padding: 5px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }

        @-webkit-keyframes fadein {
            from {
                bottom: 0;
                opacity: 0;
            }

            to {
                bottom: 30px;
                opacity: 1;
            }
        }

        @keyframes fadein {
            from {
                bottom: 0;
                opacity: 0;
            }

            to {
                bottom: 30px;
                opacity: 1;
            }
        }

        @-webkit-keyframes fadeout {
            from {
                bottom: 30px;
                opacity: 1;
            }

            to {
                bottom: 0;
                opacity: 0;
            }
        }

        @keyframes fadeout {
            from {
                bottom: 30px;
                opacity: 1;
            }

            to {
                bottom: 0;
                opacity: 0;
            }
        }

        @media (max-width: 768px) {
            .status-grid {
                grid-template-columns: 1fr;
            }

            .system-info {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <script defer>
        // Track previous SIP status to detect changes
        let previousSipStatus = null;

        // Global function to fetch SIP status (used by connect/disconnect buttons)
        async function fetchSipStatus() {
            try {
                const response = await fetch('/api/sip/status');
                const data = await response.json();
                const sipStatusDiv = document.getElementById('sip-status');
                if (sipStatusDiv) {
                    // Display actual state name (IDLE, CALLING, RINGING, CONNECTED, etc.)
                    const stateDisplay = data.state || 'UNKNOWN';
                    const statusDisplay = data.status || 'Unknown';
                    
                    // Show state prominently, status as subtitle
                    sipStatusDiv.innerHTML = `
                        <h3>SIP Status</h3>
                        <p style="font-size: 1.2em; font-weight: bold; margin: 5px 0;">${stateDisplay}</p>
                        <p style="font-size: 0.9em; color: #666;">${statusDisplay}</p>
                    `;
                    
                    // Color coding based on state
                    let statusClass = 'disconnected';
                    if (data.state === 'REGISTERED' || data.state === 'CONNECTED') {
                        statusClass = 'connected';
                    } else if (data.state === 'CALLING' || data.state === 'RINGING') {
                        statusClass = 'warning';
                    } else if (data.state === 'ERROR' || data.state === 'AUTH_FAILED' || data.state === 'TIMEOUT') {
                        statusClass = 'error';
                    }
                    
                    sipStatusDiv.className = `status-card status ${statusClass}`;
                }
                
                // Show toast when registration becomes successful
                if (data.status === 'Registered' && previousSipStatus !== 'Registered') {
                    showToast('âœ… SIP registration successful!', 'success');
                }
                
                // Update previous status
                previousSipStatus = data.status;
            } catch (error) {
                console.error('Error fetching SIP status:', error);
                const sipStatusDiv = document.getElementById('sip-status');
                if (sipStatusDiv) {
                    sipStatusDiv.innerHTML = `
                        <h3>SIP Status</h3>
                        <p>Error</p>
                    `;
                    sipStatusDiv.className = 'status-card status error';
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const sipStatusDiv = document.getElementById('sip-status');
            const wifiStatusDiv = document.getElementById('wifi-status');
            const sipForm = document.getElementById('sip-form');
            const wifiForm = document.getElementById('wifi-form');
            const toast = document.getElementById('toast');
            const wifiNetworksList = document.getElementById('wifi-networks');
            let selectedNetwork = null;

            const fetchSystemStatus = async () => {
                try {
                    const response = await fetch('/api/system/status');
                    const data = await response.json();

                    // Update system info
                    document.getElementById('uptime').textContent = data.uptime || 'Unknown';
                    document.getElementById('free-heap').textContent = data.free_heap || 'Unknown';
                    document.getElementById('ip-address').textContent = data.ip_address || 'Not connected';
                    document.getElementById('firmware-version').textContent = data.firmware_version || 'Unknown';
                } catch (error) {
                    console.error('Error fetching system status:', error);
                }
            };



            const fetchWifiStatus = async () => {
                try {
                    const response = await fetch('/api/wifi/status');
                    const data = await response.json();
                    wifiStatusDiv.textContent = `WiFi: ${data.status}`;
                    let statusClass = 'disconnected';
                    if (data.status === 'Connected') statusClass = 'connected';
                    else if (data.status === 'Connecting') statusClass = 'connecting';
                    wifiStatusDiv.className = `status-card status ${statusClass}`;
                } catch (error) {
                    console.error('Error fetching WiFi status:', error);
                    wifiStatusDiv.textContent = 'WiFi: Error';
                    wifiStatusDiv.className = 'status-card status error';
                }
            };

            const fetchSipConfig = async () => {
                try {
                    const response = await fetch('/api/sip/config');
                    const data = await response.json();
                    document.getElementById('target1').value = data.target1 || '';
                    document.getElementById('target2').value = data.target2 || '';
                    document.getElementById('server').value = data.server || '';
                    document.getElementById('username').value = data.username || '';
                    document.getElementById('password').value = data.password || '';
                } catch (error) {
                    console.error('Error fetching SIP config:', error);
                }
            };

            const fetchWifiNetworks = async () => {
                try {
                    const scanBtn = document.getElementById('scan-btn');
                    scanBtn.disabled = true;
                    scanBtn.textContent = 'Scanning...';

                    const response = await fetch('/api/wifi/scan', { method: 'POST' });
                    const data = await response.json();

                    wifiNetworksList.innerHTML = '';
                    if (data.networks && data.networks.length > 0) {
                        data.networks.forEach(network => {
                            const networkDiv = document.createElement('div');
                            networkDiv.className = 'wifi-network';
                            networkDiv.innerHTML = `
                                <span>${network.ssid}</span>
                                <span class="signal-strength">Signal: ${network.rssi} dBm</span>
                            `;
                            networkDiv.onclick = () => {
                                document.querySelectorAll('.wifi-network').forEach(n => n.classList.remove('selected'));
                                networkDiv.classList.add('selected');
                                document.getElementById('wifi-ssid').value = network.ssid;
                                selectedNetwork = network;
                            };
                            wifiNetworksList.appendChild(networkDiv);
                        });
                    } else {
                        wifiNetworksList.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No networks found</div>';
                    }

                    scanBtn.disabled = false;
                    scanBtn.textContent = 'Scan Networks';
                } catch (error) {
                    console.error('Error scanning WiFi networks:', error);
                    showToast('Error scanning networks', 'error');
                    document.getElementById('scan-btn').disabled = false;
                    document.getElementById('scan-btn').textContent = 'Scan Networks';
                }
            };

            sipForm.addEventListener('submit', async (event) => {
                event.preventDefault();
                const formData = new FormData(sipForm);
                const data = Object.fromEntries(formData.entries());

                try {
                    const response = await fetch('/api/sip/config', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    if (response.ok) {
                        showToast('SIP configuration saved successfully!', 'success');
                        setTimeout(fetchSipStatus, 2000);
                    } else {
                        const errorData = await response.json();
                        showToast(errorData.message || 'Error saving SIP configuration', 'error');
                    }
                } catch (error) {
                    console.error('Error submitting SIP form:', error);
                    showToast('Error saving SIP configuration', 'error');
                }
            });

            wifiForm.addEventListener('submit', async (event) => {
                event.preventDefault();
                const formData = new FormData(wifiForm);
                const data = Object.fromEntries(formData.entries());

                try {
                    const response = await fetch('/api/wifi/connect', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    if (response.ok) {
                        showToast('WiFi connection initiated!', 'success');
                        setTimeout(() => {
                            fetchWifiStatus();
                            fetchSystemStatus();
                        }, 5000);
                    } else {
                        const errorData = await response.json();
                        showToast(errorData.message || 'Error connecting to WiFi', 'error');
                    }
                } catch (error) {
                    console.error('Error submitting WiFi form:', error);
                    showToast('Error connecting to WiFi', 'error');
                }
            });

            // Toast queue system
            let toastQueue = [];
            let isShowingToast = false;

            function showToast(message, type = 'info') {
                toastQueue.push({ message, type });
                if (!isShowingToast) {
                    processToastQueue();
                }
            }

            function processToastQueue() {
                if (toastQueue.length === 0) {
                    isShowingToast = false;
                    return;
                }

                isShowingToast = true;
                const { message, type } = toastQueue.shift();
                
                toast.textContent = message;
                toast.className = `toast show ${type}`;
                
                setTimeout(() => {
                    toast.className = toast.className.replace('show', '');
                    // Wait for fade out animation before showing next toast
                    setTimeout(processToastQueue, 500);
                }, 3000);
            }

            // Initial fetches
            fetchSipStatus();
            fetchWifiStatus();
            fetchSipConfig();
            fetchSystemStatus();

            // Refresh status every 10 seconds
            setInterval(() => {
                fetchSipStatus();
                fetchWifiStatus();
                fetchSystemStatus();
            }, 10000);
        });
    </script>

    <script>
        // Global functions for test buttons
        async function testSipConfiguration() {
            const testBtn = document.getElementById('sip-test-btn');
            const testResult = document.getElementById('sip-test-result');

            testBtn.disabled = true;
            testBtn.textContent = 'Testing...';

            try {
                const response = await fetch('/api/sip/test', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });

                const data = await response.json();
                testResult.textContent = data.message;
                testResult.className = `status ${data.status === 'success' ? 'connected' : 'error'}`;
                testResult.style.display = 'block';

                const toast = document.getElementById('toast');
                const toastType = data.status === 'success' ? 'success' : 'error';
                const toastMessage = data.status === 'success' ? 'SIP test completed successfully!' : 'SIP test failed';
                showToast(toastMessage, toastType);

            } catch (error) {
                console.error('Error testing SIP configuration:', error);
                testResult.textContent = 'Error testing configuration';
                testResult.className = 'status error';
                testResult.style.display = 'block';
                showToast('Error testing SIP configuration', 'error');
            }

            testBtn.disabled = false;
            testBtn.textContent = 'Test SIP Configuration';
        }

        async function testCallTarget(targetNumber) {
            const targetInput = document.getElementById(`target${targetNumber}`);
            const target = targetInput.value.trim();
            
            if (!target) {
                showToast(`Please enter SIP-Target${targetNumber} first`, 'error');
                return;
            }

            // Log button press
            addLocalLogEntry('user', `ðŸ”˜ Test Call button pressed for Target${targetNumber}`);
            
            const btn = event.target;
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'Calling...';

            try {
                const response = await fetch('/api/sip/testcall', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ target: target })
                });

                const data = await response.json();
                
                if (data.status === 'success') {
                    showToast(`ðŸ“ž Test call initiated to Target${targetNumber}`, 'success');
                    addLocalLogEntry('user', `Test call initiated to: ${target}`);
                } else {
                    showToast(data.message || 'Test call failed', 'error');
                }

            } catch (error) {
                console.error('Error initiating test call:', error);
                showToast('Error initiating test call', 'error');
            }

            btn.disabled = false;
            btn.textContent = originalText;
        }

        async function restartSystem() {
            if (confirm('Are you sure you want to restart the system?')) {
                try {
                    const response = await fetch('/api/system/restart', { method: 'POST' });
                    if (response.ok) {
                        showToast('System restart initiated...', 'success');
                        setTimeout(() => {
                            window.location.reload();
                        }, 5000);
                    } else {
                        showToast('Error restarting system', 'error');
                    }
                } catch (error) {
                    console.error('Error restarting system:', error);
                    showToast('Error restarting system', 'error');
                }
            }
        }

        async function scanWifiNetworks() {
            const scanBtn = document.getElementById('scan-btn');
            const wifiNetworksList = document.getElementById('wifi-networks');

            scanBtn.disabled = true;
            scanBtn.textContent = 'Scanning...';

            try {
                const response = await fetch('/api/wifi/scan', { method: 'POST' });
                const data = await response.json();

                wifiNetworksList.innerHTML = '';
                if (data.networks && data.networks.length > 0) {
                    data.networks.forEach(network => {
                        const networkDiv = document.createElement('div');
                        networkDiv.className = 'wifi-network';
                        networkDiv.innerHTML = `
                            <span>${network.ssid}</span>
                            <span class="signal-strength">Signal: ${network.rssi} dBm</span>
                        `;
                        networkDiv.onclick = () => {
                            document.querySelectorAll('.wifi-network').forEach(n => n.classList.remove('selected'));
                            networkDiv.classList.add('selected');
                            document.getElementById('wifi-ssid').value = network.ssid;
                        };
                        wifiNetworksList.appendChild(networkDiv);
                    });
                } else {
                    wifiNetworksList.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No networks found</div>';
                }

                scanBtn.disabled = false;
                scanBtn.textContent = 'Scan Networks';
            } catch (error) {
                console.error('Error scanning WiFi networks:', error);
                showToast('Error scanning networks', 'error');
                scanBtn.disabled = false;
                scanBtn.textContent = 'Scan Networks';
            }
        }

        // Toast queue system (global version)
        let toastQueue = [];
        let isShowingToast = false;

        function showToast(message, type = 'info') {
            toastQueue.push({ message, type });
            if (!isShowingToast) {
                processToastQueue();
            }
        }

        function processToastQueue() {
            if (toastQueue.length === 0) {
                isShowingToast = false;
                return;
            }

            isShowingToast = true;
            const { message, type } = toastQueue.shift();
            const toast = document.getElementById('toast');
            
            toast.textContent = message;
            toast.className = `toast show ${type}`;
            
            setTimeout(() => {
                toast.className = toast.className.replace('show', '');
                // Wait for fade out animation before showing next toast
                setTimeout(processToastQueue, 500);
            }, 3000);
        }

        // Add a local log entry to the display
        function addLocalLogEntry(type, message) {
            const logDiv = document.getElementById('sip-log');
            const entryDiv = document.createElement('div');
            entryDiv.style.marginBottom = '5px';
            
            // Color code by type
            let color = '#d4d4d4';
            if (type === 'error') color = '#f48771';
            else if (type === 'info') color = '#4ec9b0';
            else if (type === 'user') color = '#c586c0'; // Purple for user actions
            
            // Format current time
            const now = new Date();
            const timeStr = now.toLocaleString('en-GB', { 
                year: 'numeric', 
                month: '2-digit', 
                day: '2-digit',
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit',
                hour12: false 
            });
            
            entryDiv.innerHTML = `<span style="color: #888;">[${timeStr}]</span> <span style="color: ${color};">[${type.toUpperCase()}]</span> ${escapeHtml(message)}`;
            logDiv.appendChild(entryDiv);
            
            // Auto-scroll to bottom
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // SIP Connection Management
        async function connectToSip() {
            // Log button press
            addLocalLogEntry('user', 'ðŸ”˜ Connect button pressed');
            
            const connectBtn = document.getElementById('sip-connect-btn');
            connectBtn.disabled = true;
            connectBtn.textContent = 'Connecting...';

            try {
                // First check current status
                const statusResponse = await fetch('/api/sip/status');
                const statusData = await statusResponse.json();
                
                // If already registered, show info toast and return
                if (statusData.status === 'Registered') {
                    showToast('â„¹ï¸ Already registered to SIP server', 'info');
                    connectBtn.disabled = false;
                    connectBtn.textContent = 'Connect to SIP';
                    return;
                }
                
                // Proceed with connection
                const response = await fetch('/api/sip/connect', { method: 'POST' });
                
                if (!response.ok) {
                    console.error('HTTP error:', response.status, response.statusText);
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Connect response:', data);
                
                if (data.status === 'success') {
                    showToast('ðŸ”„ Connecting to SIP server...', 'info');
                    // Poll more frequently for a few seconds to catch registration success
                    let pollCount = 0;
                    const pollInterval = setInterval(() => {
                        fetchSipStatus();
                        pollCount++;
                        if (pollCount >= 10) { // Poll for 5 seconds (500ms * 10)
                            clearInterval(pollInterval);
                        }
                    }, 500);
                } else {
                    showToast(data.message || 'Failed to connect to SIP', 'error');
                }
            } catch (error) {
                console.error('Error connecting to SIP:', error);
                showToast(`Error: ${error.message}`, 'error');
            }

            connectBtn.disabled = false;
            connectBtn.textContent = 'Connect to SIP';
        }

        async function disconnectFromSip() {
            // Log button press
            addLocalLogEntry('user', 'ðŸ”˜ Disconnect button pressed');
            
            const disconnectBtn = document.getElementById('sip-disconnect-btn');
            disconnectBtn.disabled = true;
            disconnectBtn.textContent = 'Disconnecting...';

            try {
                const response = await fetch('/api/sip/disconnect', { method: 'POST' });
                
                if (!response.ok) {
                    console.error('HTTP error:', response.status, response.statusText);
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Disconnect response:', data);
                
                if (data.status === 'success') {
                    showToast('Disconnected from SIP', 'success');
                } else {
                    showToast(data.message || 'Failed to disconnect', 'error');
                }
                
                setTimeout(fetchSipStatus, 1000);
            } catch (error) {
                console.error('Error disconnecting from SIP:', error);
                showToast(`Error: ${error.message}`, 'error');
            }

            disconnectBtn.disabled = false;
            disconnectBtn.textContent = 'Disconnect';
        }

        // SIP Logging
        let lastLogTimestamp = 0;
        let logRefreshInterval = null;
        let seenLogEntries = new Set(); // Track seen entries by hash

        // Create a simple hash for log entry to detect duplicates
        function logEntryHash(entry) {
            return `${entry.timestamp}_${entry.type}_${entry.message.substring(0, 50)}`;
        }

        async function refreshSipLog() {
            try {
                const response = await fetch(`/api/sip/log?since=${lastLogTimestamp}`);
                const data = await response.json();
                
                if (data.entries && data.entries.length > 0) {
                    const logDiv = document.getElementById('sip-log');
                    
                    // Clear "waiting" message on first entry
                    if (lastLogTimestamp === 0) {
                        logDiv.innerHTML = '';
                    }
                    
                    // Track the highest timestamp in this batch
                    let maxTimestamp = lastLogTimestamp;
                    
                    data.entries.forEach(entry => {
                        // Check if we've already seen this entry
                        const hash = logEntryHash(entry);
                        if (seenLogEntries.has(hash)) {
                            return; // Skip duplicate
                        }
                        seenLogEntries.add(hash);
                        
                        // Track highest timestamp
                        maxTimestamp = Math.max(maxTimestamp, entry.timestamp);
                        
                        const entryDiv = document.createElement('div');
                        entryDiv.style.marginBottom = '5px';
                        
                        // Color code by type
                        let color = '#d4d4d4';
                        if (entry.type === 'error') color = '#f48771';
                        else if (entry.type === 'info') color = '#4ec9b0';
                        else if (entry.type === 'sent') color = '#dcdcaa';
                        else if (entry.type === 'received') color = '#9cdcfe';
                        
                        // Format timestamp - if it's a real timestamp (> year 2000), show date-time, otherwise show uptime
                        let timeStr;
                        if (entry.timestamp > 946684800000) { // Jan 1, 2000 in ms
                            // Real timestamp from NTP - show full date and time
                            const date = new Date(entry.timestamp);
                            timeStr = date.toLocaleString('en-GB', { 
                                year: 'numeric', 
                                month: '2-digit', 
                                day: '2-digit',
                                hour: '2-digit', 
                                minute: '2-digit', 
                                second: '2-digit',
                                hour12: false 
                            });
                        } else {
                            // Uptime timestamp - show as HH:MM:SS
                            const totalSeconds = Math.floor(entry.timestamp / 1000);
                            const hours = Math.floor(totalSeconds / 3600);
                            const minutes = Math.floor((totalSeconds % 3600) / 60);
                            const seconds = totalSeconds % 60;
                            timeStr = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                        }
                        entryDiv.innerHTML = `<span style="color: #888;">[${timeStr}]</span> <span style="color: ${color};">[${entry.type.toUpperCase()}]</span> ${escapeHtml(entry.message)}`;
                        
                        logDiv.appendChild(entryDiv);
                    });
                    
                    // Update lastLogTimestamp after processing all entries
                    // Add 1 to ensure we don't fetch the same timestamp again
                    if (maxTimestamp > lastLogTimestamp) {
                        lastLogTimestamp = maxTimestamp + 1;
                    }
                    
                    // Auto-scroll to bottom
                    logDiv.scrollTop = logDiv.scrollHeight;
                }
            } catch (error) {
                console.error('Error fetching SIP log:', error);
            }
        }

        function clearSipLogDisplay() {
            document.getElementById('sip-log').innerHTML = '<div style="color: #888;">Log cleared. Waiting for new entries...</div>';
            lastLogTimestamp = Date.now();
            seenLogEntries.clear(); // Clear the seen entries set
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // NTP Functions
        async function fetchNtpStatus() {
            try {
                const response = await fetch('/api/ntp/status');
                const data = await response.json();
                
                document.getElementById('ntp-synced').innerHTML = data.synced ? '&#x2705; Yes' : '&#x274C; No';
                document.getElementById('ntp-current-time').textContent = data.current_time || 'Not synced';
            } catch (error) {
                console.error('Error fetching NTP status:', error);
                document.getElementById('ntp-synced').textContent = 'Error';
                document.getElementById('ntp-current-time').textContent = 'Error';
            }
        }

        async function fetchNtpConfig() {
            try {
                const response = await fetch('/api/ntp/config');
                const data = await response.json();
                document.getElementById('ntp-server').value = data.server || 'pool.ntp.org';
                document.getElementById('ntp-timezone').value = data.timezone || 'UTC0';
            } catch (error) {
                console.error('Error fetching NTP config:', error);
            }
        }

        async function syncNtpTime() {
            const syncBtn = event.target;
            syncBtn.disabled = true;
            syncBtn.textContent = 'Syncing...';

            try {
                const response = await fetch('/api/ntp/sync', { method: 'POST' });
                const data = await response.json();
                
                if (data.status === 'success') {
                    showToast('NTP sync initiated', 'success');
                    setTimeout(fetchNtpStatus, 2000);
                } else {
                    showToast('Failed to sync NTP', 'error');
                }
            } catch (error) {
                console.error('Error syncing NTP:', error);
                showToast('Error syncing NTP', 'error');
            }

            syncBtn.disabled = false;
            syncBtn.textContent = 'Force Sync Now';
        }

        // DTMF Security Functions
        let lastDtmfLogTimestamp = 0;
        let seenDtmfLogEntries = new Set();

        function logDtmfEntryHash(entry) {
            return `${entry.timestamp}_${entry.type}_${entry.command}`;
        }

        async function fetchDtmfSecurityConfig() {
            try {
                const response = await fetch('/api/dtmf/security');
                const data = await response.json();
                
                // Update display
                document.getElementById('dtmf-pin-enabled').innerHTML = data.pin_enabled ? '&#x2705; Yes' : '&#x274C; No';
                document.getElementById('dtmf-pin-code').textContent = data.pin_enabled ? '****' : 'Disabled';
                document.getElementById('dtmf-timeout').textContent = `${data.timeout_ms} ms`;
                document.getElementById('dtmf-max-attempts').textContent = data.max_attempts;
                
                // Update form inputs
                document.getElementById('dtmf-pin-enabled-input').checked = data.pin_enabled;
                document.getElementById('dtmf-pin-code-input').value = data.pin_code;
                document.getElementById('dtmf-timeout-input').value = data.timeout_ms;
                document.getElementById('dtmf-max-attempts-input').value = data.max_attempts;
            } catch (error) {
                console.error('Error fetching DTMF security config:', error);
            }
        }

        async function refreshDtmfLogs() {
            try {
                const response = await fetch(`/api/dtmf/logs?since=${lastDtmfLogTimestamp}`);
                const data = await response.json();
                
                if (data.logs && data.logs.length > 0) {
                    const logDiv = document.getElementById('dtmf-log');
                    
                    // Clear "waiting" message on first entry
                    if (lastDtmfLogTimestamp === 0) {
                        logDiv.innerHTML = '';
                    }
                    
                    let maxTimestamp = lastDtmfLogTimestamp;
                    
                    data.logs.forEach(entry => {
                        const hash = logDtmfEntryHash(entry);
                        if (seenDtmfLogEntries.has(hash)) {
                            return;
                        }
                        seenDtmfLogEntries.add(hash);
                        
                        maxTimestamp = Math.max(maxTimestamp, entry.timestamp);
                        
                        const entryDiv = document.createElement('div');
                        entryDiv.style.marginBottom = '5px';
                        
                        // Color code and icon by type and success
                        let color, icon;
                        if (entry.type === 'config_change') {
                            color = '#dcdcaa';  // Yellow for config changes
                            icon = 'âš™ï¸';
                        } else {
                            color = entry.success ? '#4ec9b0' : '#f48771';
                            icon = entry.success ? 'âœ…' : 'âŒ';
                        }
                        
                        // Format timestamp
                        let timeStr;
                        if (entry.timestamp > 946684800000) {
                            const date = new Date(entry.timestamp);
                            timeStr = date.toLocaleString('en-GB', { 
                                year: 'numeric', 
                                month: '2-digit', 
                                day: '2-digit',
                                hour: '2-digit', 
                                minute: '2-digit', 
                                second: '2-digit',
                                hour12: false 
                            });
                        } else {
                            const totalSeconds = Math.floor(entry.timestamp / 1000);
                            const hours = Math.floor(totalSeconds / 3600);
                            const minutes = Math.floor((totalSeconds % 3600) / 60);
                            const seconds = totalSeconds % 60;
                            timeStr = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                        }
                        
                        // Format message based on type
                        let message;
                        if (entry.type === 'config_change') {
                            message = `${icon} Configuration updated: ${entry.reason || entry.command}`;
                            if (entry.caller) {
                                message += ` by ${entry.caller}`;
                            }
                        } else {
                            message = `${icon} ${entry.command} â†’ ${entry.action || entry.type}`;
                            if (entry.caller) {
                                message += ` (${entry.caller})`;
                            }
                            if (!entry.success && entry.reason) {
                                message += ` - ${entry.reason}`;
                            }
                        }
                        
                        entryDiv.innerHTML = `<span style="color: #888;">[${timeStr}]</span> <span style="color: ${color};">${escapeHtml(message)}</span>`;
                        logDiv.appendChild(entryDiv);
                    });
                    
                    if (maxTimestamp > lastDtmfLogTimestamp) {
                        lastDtmfLogTimestamp = maxTimestamp + 1;
                    }
                    
                    logDiv.scrollTop = logDiv.scrollHeight;
                }
            } catch (error) {
                console.error('Error fetching DTMF logs:', error);
            }
        }

        function clearDtmfLogDisplay() {
            document.getElementById('dtmf-log').innerHTML = '<div style="color: #888;">Log cleared. Waiting for new entries...</div>';
            lastDtmfLogTimestamp = Date.now();
            seenDtmfLogEntries.clear();
        }

        // Auto-refresh log
        document.addEventListener('DOMContentLoaded', () => {
            const autoRefreshCheckbox = document.getElementById('auto-refresh-log');
            
            function startLogRefresh() {
                if (logRefreshInterval) clearInterval(logRefreshInterval);
                logRefreshInterval = setInterval(refreshSipLog, 500);
            }
            
            function stopLogRefresh() {
                if (logRefreshInterval) {
                    clearInterval(logRefreshInterval);
                    logRefreshInterval = null;
                }
            }
            
            autoRefreshCheckbox.addEventListener('change', (e) => {
                if (e.target.checked) {
                    startLogRefresh();
                } else {
                    stopLogRefresh();
                }
            });
            
            // Start auto-refresh by default
            startLogRefresh();
            
            // Initial log fetch
            refreshSipLog();
            
            // Load NTP configuration and status
            fetchNtpConfig();
            fetchNtpStatus();
            
            // Refresh NTP status every 5 seconds
            setInterval(fetchNtpStatus, 5000);
            
            // Load DTMF security configuration
            fetchDtmfSecurityConfig();
            
            // Refresh DTMF logs every 5 seconds (reduced from 2 to minimize log spam)
            setInterval(refreshDtmfLogs, 5000);
            refreshDtmfLogs();
            
            // DTMF Security form submission
            const dtmfSecurityForm = document.getElementById('dtmf-security-form');
            dtmfSecurityForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const formData = new FormData(dtmfSecurityForm);
                const data = {
                    pin_enabled: document.getElementById('dtmf-pin-enabled-input').checked,
                    pin_code: formData.get('pin_code'),
                    timeout_ms: parseInt(formData.get('timeout_ms')),
                    max_attempts: parseInt(formData.get('max_attempts'))
                };

                try {
                    const response = await fetch('/api/dtmf/security', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        showToast('DTMF security configuration saved!', 'success');
                        setTimeout(fetchDtmfSecurityConfig, 500);
                    } else {
                        const errorText = await response.text();
                        showToast(`Failed to save: ${errorText}`, 'error');
                    }
                } catch (error) {
                    console.error('Error saving DTMF security config:', error);
                    showToast('Error saving DTMF security configuration', 'error');
                }
            });
            
            // NTP form submission
            const ntpForm = document.getElementById('ntp-form');
            ntpForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const formData = new FormData(ntpForm);
                const data = {
                    server: formData.get('server'),
                    timezone: formData.get('timezone')
                };

                try {
                    const response = await fetch('/api/ntp/config', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    const result = await response.json();
                    
                    if (result.status === 'success') {
                        showToast('NTP configuration saved!', 'success');
                        setTimeout(fetchNtpStatus, 2000);
                    } else {
                        showToast('Failed to save NTP configuration', 'error');
                    }
                } catch (error) {
                    console.error('Error saving NTP config:', error);
                    showToast('Error saving NTP configuration', 'error');
                }
            });
        });
    </script>
</head>

<body>
    <div class="container">
        <h1>ESP32 SIP Door Station</h1>

        <!-- System Status Dashboard -->
        <div class="status-grid">
            <div id="wifi-status" class="status-card status disconnected">
                <h3>WiFi Status</h3>
                <p>Loading...</p>
            </div>
            <div id="sip-status" class="status-card status disconnected">
                <h3>SIP Status</h3>
                <p>Loading...</p>
            </div>
        </div>

        <!-- System Information -->
        <div class="form-section">
            <h2>System Information</h2>
            <div class="system-info">
                <div><strong>Uptime:</strong> <span id="uptime">Loading...</span></div>
                <div><strong>Free Heap:</strong> <span id="free-heap">Loading...</span></div>
                <div><strong>IP Address:</strong> <span id="ip-address">Loading...</span></div>
                <div><strong>Firmware:</strong> <span id="firmware-version">Loading...</span></div>
            </div>
            <div class="button-group" style="margin-top: 15px;">
                <button onclick="restartSystem()" class="danger">Restart System</button>
            </div>
        </div>

        <!-- NTP Time Configuration -->
        <div class="form-section">
            <h2>NTP Time Synchronization</h2>
            <div class="system-info" style="margin-bottom: 15px;">
                <div><strong>Time Synced:</strong> <span id="ntp-synced">Loading...</span></div>
                <div><strong>Current Time:</strong> <span id="ntp-current-time">Loading...</span></div>
            </div>
            <form id="ntp-form">
                <label for="ntp-server">NTP Server:</label>
                <input type="text" id="ntp-server" name="server" placeholder="pool.ntp.org" required>

                <label for="ntp-timezone">Timezone:</label>
                <input type="text" id="ntp-timezone" name="timezone" placeholder="Europe/Berlin or UTC0" required>
                <small style="color: #666; margin-bottom: 10px; display: block;">
                    Examples: Europe/Berlin, America/New_York, Asia/Tokyo, UTC, or POSIX strings like CET-1CEST,M3.5.0,M10.5.0/3
                </small>

                <div class="button-group">
                    <button type="submit">Save NTP Configuration</button>
                    <button type="button" onclick="syncNtpTime()" class="secondary">Force Sync Now</button>
                </div>
            </form>
        </div>

        <!-- DTMF Security Configuration -->
        <div class="form-section">
            <h2>DTMF Security Configuration</h2>
            <div class="system-info" style="margin-bottom: 15px;">
                <div><strong>PIN Enabled:</strong> <span id="dtmf-pin-enabled">Loading...</span></div>
                <div><strong>Current PIN:</strong> <span id="dtmf-pin-code">****</span></div>
                <div><strong>Timeout:</strong> <span id="dtmf-timeout">Loading...</span></div>
                <div><strong>Max Attempts:</strong> <span id="dtmf-max-attempts">Loading...</span></div>
            </div>
            <form id="dtmf-security-form">
                <label style="display: flex; align-items: center; margin-bottom: 15px;">
                    <input type="checkbox" id="dtmf-pin-enabled-input" name="pin_enabled" style="margin-right: 10px;">
                    <strong>Enable PIN Protection</strong>
                </label>

                <label for="dtmf-pin-code">PIN Code (1-8 digits):</label>
                <input type="text" id="dtmf-pin-code-input" name="pin_code" placeholder="1234" pattern="[0-9]{1,8}" maxlength="8" required>
                <small style="color: #666; margin-bottom: 10px; display: block;">
                    When enabled, door opener requires: *[PIN]# (e.g., *1234#). When disabled, legacy *1# works.
                </small>

                <label for="dtmf-timeout">Command Timeout (ms):</label>
                <input type="number" id="dtmf-timeout-input" name="timeout_ms" placeholder="10000" min="5000" max="30000" step="1000" required>
                <small style="color: #666; margin-bottom: 10px; display: block;">
                    Time allowed to complete command sequence (5000-30000 ms)
                </small>

                <label for="dtmf-max-attempts">Max Failed Attempts:</label>
                <input type="number" id="dtmf-max-attempts-input" name="max_attempts" placeholder="3" min="1" max="10" required>
                <small style="color: #666; margin-bottom: 10px; display: block;">
                    Number of failed attempts before rate limiting (per call)
                </small>

                <button type="submit">Save Security Configuration</button>
            </form>
        </div>

        <!-- DTMF Security Logs -->
        <div class="form-section">
            <h2>DTMF Security Logs</h2>
            <div class="button-group">
                <button onclick="refreshDtmfLogs()" class="secondary">Refresh Logs</button>
                <button onclick="clearDtmfLogDisplay()" class="secondary">Clear Display</button>
            </div>
            <div id="dtmf-log" style="background-color: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 4px; max-height: 400px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 12px; margin-top: 10px;">
                <div style="color: #888;">Waiting for DTMF security log entries...</div>
            </div>
        </div>

        <!-- WiFi Configuration -->
        <div class="form-section">
            <h2>WiFi Configuration</h2>
            <div class="button-group">
                <button id="scan-btn" onclick="scanWifiNetworks()" class="secondary">Scan Networks</button>
            </div>
            <div id="wifi-networks" class="wifi-networks"></div>

            <form id="wifi-form">
                <label for="wifi-ssid">Network Name (SSID):</label>
                <input type="text" id="wifi-ssid" name="ssid" required>

                <label for="wifi-password">Password:</label>
                <input type="password" id="wifi-password" name="password" autocomplete="new-password">

                <button type="submit">Connect to WiFi</button>
            </form>
        </div>

        <!-- SIP Configuration -->
        <div class="form-section">
            <h2>SIP Configuration</h2>
            <form id="sip-form">
                <label for="target1">SIP-Target1 (Apartment 1, e.g., sip:apartment1@domain.com):</label>
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <input type="text" id="target1" name="target1" placeholder="sip:apartment1@domain.com" required style="flex: 1; margin-bottom: 0;">
                    <button type="button" onclick="testCallTarget(1)" class="secondary" style="white-space: nowrap;">Test Call</button>
                </div>

                <label for="target2">SIP-Target2 (Apartment 2, e.g., sip:apartment2@domain.com):</label>
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <input type="text" id="target2" name="target2" placeholder="sip:apartment2@domain.com" required style="flex: 1; margin-bottom: 0;">
                    <button type="button" onclick="testCallTarget(2)" class="secondary" style="white-space: nowrap;">Test Call</button>
                </div>

                <label for="server">SIP Server (e.g., sip.domain.com):</label>
                <input type="text" id="server" name="server" required>

                <label for="username">Username:</label>
                <input type="text" id="username" name="username" required>

                <label for="password">Password:</label>
                <input type="password" id="password" name="password" required autocomplete="current-password">

                <div class="button-group">
                    <button type="submit">Save Configuration</button>
                    <button type="button" id="sip-test-btn" onclick="testSipConfiguration()" class="secondary">Test
                        Configuration</button>
                    <button type="button" id="sip-connect-btn" onclick="connectToSip()">Connect to SIP</button>
                    <button type="button" id="sip-disconnect-btn" onclick="disconnectFromSip()" class="danger">Disconnect</button>
                </div>
            </form>
            <div id="sip-test-result" class="status" style="display: none; margin-top: 10px;"></div>
        </div>

        <!-- SIP Logging -->
        <div class="form-section">
            <h2>SIP Connection Log</h2>
            <div class="button-group">
                <button onclick="refreshSipLog()" class="secondary">Refresh Log</button>
                <button onclick="clearSipLogDisplay()" class="secondary">Clear Display</button>
                <label style="margin-left: auto; display: flex; align-items: center;">
                    <input type="checkbox" id="auto-refresh-log" checked style="margin-right: 5px;">
                    Auto-refresh (500ms)
                </label>
            </div>
            <div id="sip-log" style="background-color: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 4px; max-height: 400px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 12px; margin-top: 10px;">
                <div style="color: #888;">Waiting for SIP log entries...</div>
            </div>
        </div>

        <!-- DTMF Information -->
        <div class="form-section">
            <h2>DTMF Control Codes</h2>
            <div class="system-info">
                <div><strong>*1:</strong> Open Door (3 seconds)</div>
                <div><strong>*2:</strong> Toggle Light</div>
                <div><strong>#:</strong> End Call</div>
                <div><strong>Bell 1:</strong> GPIO 21 (Calls SIP-Target1)</div>
                <div><strong>Bell 2:</strong> GPIO 4 (Calls SIP-Target2)</div>
                <div><strong>Door Relay:</strong> GPIO 5</div>
                <div><strong>Light Relay:</strong> GPIO 6</div>
            </div>
        </div>

        <!-- Testing Information -->
        <div class="form-section">
            <h2>ðŸ§ª Testing</h2>
            <div class="system-info">
                <div><strong>BOOT Button:</strong> GPIO 0 (Press to simulate doorbell)</div>
                <div><strong>Function:</strong> Triggers SIP call to SIP-Target1</div>
            </div>
            <p style="color: #666; margin-top: 10px; font-size: 14px;">
                Press the physical BOOT button on your ESP32-S3 to simulate a doorbell press and initiate a SIP call to the first apartment.
            </p>
        </div>
    </div>
    <div id="toast" class="toast"></div>
</body>

</html>