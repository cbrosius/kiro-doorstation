<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>ESP32 SIP Door Station</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🔔</text></svg>">
  <style>
    /* ===== CSS Custom Properties (Task 2.1) ===== */
    
    /* Light Theme (Default) */
    :root {
      /* Primary Colors */
      --color-primary: #4CAF50;
      --color-primary-dark: #45a049;
      --color-primary-light: #81C784;
      --color-danger: #dc3545;
      --color-warning: #ffc107;
      --color-info: #17a2b8;
      --color-success: #28a745;
      
      /* Background Colors */
      --color-bg: #f4f4f4;
      --color-surface: #ffffff;
      --color-hover: #f8f9fa;
      --color-active: #e9ecef;
      
      /* Text Colors */
      --color-text: #333333;
      --color-text-secondary: #666666;
      --color-text-muted: #999999;
      --color-text-inverse: #ffffff;
      
      /* Border Colors */
      --color-border: #dddddd;
      --color-border-light: #eeeeee;
      --color-border-dark: #cccccc;
      
      /* Status Colors */
      --color-status-connected: #28a745;
      --color-status-disconnected: #dc3545;
      --color-status-connecting: #ffc107;
      --color-status-inactive: #6c757d;
      
      /* Shadows */
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.1);
      --shadow-md: 0 2px 4px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 4px 8px rgba(0, 0, 0, 0.15);
      --shadow-xl: 0 8px 16px rgba(0, 0, 0, 0.2);
      
      /* Spacing */
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 16px;
      --spacing-lg: 24px;
      --spacing-xl: 32px;
      
      /* Typography */
      --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      --font-size-xs: 12px;
      --font-size-sm: 14px;
      --font-size-base: 16px;
      --font-size-lg: 18px;
      --font-size-xl: 20px;
      --font-size-2xl: 24px;
      --font-weight-normal: 400;
      --font-weight-medium: 500;
      --font-weight-bold: 600;
      
      /* Layout */
      --header-height: 60px;
      --sidebar-width: 240px;
      --sidebar-collapsed-width: 60px;
      --border-radius: 8px;
      --border-radius-sm: 4px;
      --border-radius-lg: 12px;
      
      /* Transitions */
      --transition-fast: 150ms ease;
      --transition-base: 200ms ease;
      --transition-slow: 300ms ease;
    }
    
    /* Dark Theme */
    [data-theme="dark"] {
      /* Primary Colors */
      --color-primary: #66bb6a;
      --color-primary-dark: #4caf50;
      --color-primary-light: #81c784;
      --color-danger: #ef5350;
      --color-warning: #ffca28;
      --color-info: #29b6f6;
      --color-success: #66bb6a;
      
      /* Background Colors */
      --color-bg: #1e1e1e;
      --color-surface: #2d2d2d;
      --color-hover: #3a3a3a;
      --color-active: #404040;
      
      /* Text Colors */
      --color-text: #e0e0e0;
      --color-text-secondary: #b0b0b0;
      --color-text-muted: #808080;
      --color-text-inverse: #1e1e1e;
      
      /* Border Colors */
      --color-border: #404040;
      --color-border-light: #353535;
      --color-border-dark: #4a4a4a;
      
      /* Status Colors */
      --color-status-connected: #66bb6a;
      --color-status-disconnected: #ef5350;
      --color-status-connecting: #ffca28;
      --color-status-inactive: #9e9e9e;
      
      /* Shadows */
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 2px 4px rgba(0, 0, 0, 0.3);
      --shadow-lg: 0 4px 8px rgba(0, 0, 0, 0.4);
      --shadow-xl: 0 8px 16px rgba(0, 0, 0, 0.5);
    }
    
    /* ===== Base Styles ===== */
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html {
      font-size: 16px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    body {
      font-family: var(--font-family);
      font-size: var(--font-size-base);
      line-height: 1.5;
      color: var(--color-text);
      background-color: var(--color-bg);
      overflow-x: hidden;
    }
    
    /* ===== Header Styles (Task 2.2) ===== */
    
    .app-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: var(--header-height);
      background-color: var(--color-surface);
      border-bottom: 1px solid var(--color-border);
      box-shadow: var(--shadow-sm);
      display: flex;
      align-items: center;
      padding: 0 var(--spacing-md);
      gap: var(--spacing-md);
      z-index: 1000;
    }
    
    .menu-toggle {
      display: none;
      width: 44px;
      height: 44px;
      background: none;
      border: none;
      font-size: var(--font-size-2xl);
      color: var(--color-text);
      cursor: pointer;
      border-radius: var(--border-radius-sm);
      transition: background-color var(--transition-fast);
    }
    
    .menu-toggle:hover {
      background-color: var(--color-hover);
    }
    
    .menu-toggle:active {
      background-color: var(--color-active);
    }
    
    .app-title {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-bold);
      color: var(--color-text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .header-actions {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      margin-left: auto;
    }
    
    .global-search {
      width: 250px;
      height: 36px;
      padding: 0 var(--spacing-md);
      background-color: var(--color-bg);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      font-size: var(--font-size-sm);
      color: var(--color-text);
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
    }
    
    .global-search:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
    }
    
    .global-search::placeholder {
      color: var(--color-text-muted);
    }
    
    .theme-toggle {
      width: 44px;
      height: 44px;
      background: none;
      border: none;
      font-size: var(--font-size-xl);
      cursor: pointer;
      border-radius: var(--border-radius-sm);
      transition: background-color var(--transition-fast);
    }
    
    .theme-toggle:hover {
      background-color: var(--color-hover);
    }
    
    .theme-toggle:active {
      background-color: var(--color-active);
    }
    
    .version {
      font-size: var(--font-size-sm);
      color: var(--color-text-secondary);
      white-space: nowrap;
    }
    
    /* ===== Sidebar Styles (Task 2.2) ===== */
    
    .sidebar {
      position: fixed;
      top: var(--header-height);
      left: 0;
      width: var(--sidebar-width);
      height: calc(100vh - var(--header-height));
      background-color: var(--color-surface);
      border-right: 1px solid var(--color-border);
      overflow-y: auto;
      overflow-x: hidden;
      transition: transform var(--transition-slow);
      z-index: 900;
    }
    
    .nav-menu {
      list-style: none;
      padding: var(--spacing-sm) 0;
    }
    
    .nav-item {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      padding: var(--spacing-md) var(--spacing-lg);
      color: var(--color-text);
      cursor: pointer;
      transition: background-color var(--transition-fast), color var(--transition-fast);
      position: relative;
      user-select: none;
    }
    
    .nav-item:hover {
      background-color: var(--color-hover);
    }
    
    .nav-item.active {
      background-color: var(--color-primary);
      color: var(--color-text-inverse);
      font-weight: var(--font-weight-medium);
    }
    
    .nav-item.active::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background-color: var(--color-primary-dark);
    }
    
    .nav-icon {
      font-size: var(--font-size-xl);
      flex-shrink: 0;
      width: 24px;
      text-align: center;
    }
    
    .nav-label {
      flex: 1;
      font-size: var(--font-size-base);
    }
    
    .unsaved-indicator {
      color: var(--color-warning);
      font-size: var(--font-size-lg);
      flex-shrink: 0;
    }
    
    /* ===== Main Content Area (Task 2.2) ===== */
    
    .main-content {
      margin-top: var(--header-height);
      margin-left: var(--sidebar-width);
      padding: var(--spacing-lg);
      min-height: calc(100vh - var(--header-height));
      transition: margin-left var(--transition-slow);
    }
    
    .content-section {
      opacity: 0;
      transition: opacity var(--transition-base);
    }
    
    .content-section.active {
      opacity: 1;
    }
    
    .content-section h2 {
      font-size: var(--font-size-2xl);
      font-weight: var(--font-weight-bold);
      color: var(--color-text);
      margin-bottom: var(--spacing-lg);
    }
    
    /* ===== Status Panel Styles (Task 2.3) ===== */
    
    .status-panel {
      background-color: var(--color-surface);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      margin-bottom: var(--spacing-lg);
      box-shadow: var(--shadow-sm);
      overflow: hidden;
    }
    
    .status-toggle {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--spacing-md) var(--spacing-lg);
      background: none;
      border: none;
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-medium);
      color: var(--color-text);
      cursor: pointer;
      transition: background-color var(--transition-fast);
    }
    
    .status-toggle:hover {
      background-color: var(--color-hover);
    }
    
    .toggle-icon {
      font-size: var(--font-size-base);
      transition: transform var(--transition-base);
    }
    
    .status-panel.collapsed .toggle-icon {
      transform: rotate(-90deg);
    }
    
    .status-content {
      max-height: 500px;
      overflow: hidden;
      transition: max-height var(--transition-slow), opacity var(--transition-slow);
      opacity: 1;
    }
    
    .status-panel.collapsed .status-content {
      max-height: 0;
      opacity: 0;
    }
    
    .status-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--spacing-md);
      padding: var(--spacing-md) var(--spacing-lg) var(--spacing-lg);
    }
    
    .status-card {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      padding: var(--spacing-md);
      background-color: var(--color-bg);
      border: 2px solid var(--color-border);
      border-radius: var(--border-radius);
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
    }
    
    .status-card[data-status="connected"],
    .status-card[data-status="registered"] {
      border-color: var(--color-status-connected);
    }
    
    .status-card[data-status="disconnected"],
    .status-card[data-status="error"] {
      border-color: var(--color-status-disconnected);
    }
    
    .status-card[data-status="connecting"] {
      border-color: var(--color-status-connecting);
    }
    
    .status-card[data-status="closed"],
    .status-card[data-status="off"],
    .status-card[data-status="inactive"] {
      border-color: var(--color-status-inactive);
    }
    
    .status-icon {
      font-size: var(--font-size-2xl);
      flex-shrink: 0;
    }
    
    .status-info {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-xs);
      flex: 1;
    }
    
    .status-label {
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      color: var(--color-text-secondary);
    }
    
    .status-value {
      font-size: var(--font-size-base);
      font-weight: var(--font-weight-medium);
      color: var(--color-text);
    }
    
    /* ===== Toast Notification Styles ===== */
    
    .toast-container {
      position: fixed;
      top: calc(var(--header-height) + var(--spacing-md));
      right: var(--spacing-md);
      z-index: 2000;
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
      max-width: 400px;
    }
    
    .toast {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      padding: var(--spacing-md);
      background-color: var(--color-surface);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-lg);
      opacity: 0;
      transform: translateX(100%);
      transition: opacity var(--transition-base), transform var(--transition-base);
    }
    
    .toast.show {
      opacity: 1;
      transform: translateX(0);
    }
    
    .toast-icon {
      font-size: var(--font-size-xl);
      flex-shrink: 0;
    }
    
    .toast-message {
      flex: 1;
      font-size: var(--font-size-sm);
      color: var(--color-text);
    }
    
    .toast-close {
      width: 24px;
      height: 24px;
      background: none;
      border: none;
      font-size: var(--font-size-lg);
      color: var(--color-text-secondary);
      cursor: pointer;
      border-radius: var(--border-radius-sm);
      transition: background-color var(--transition-fast);
    }
    
    .toast-close:hover {
      background-color: var(--color-hover);
    }
    
    /* ===== Search Results Styles ===== */
    
    .search-results {
      position: absolute;
      top: calc(var(--header-height) - var(--spacing-sm));
      right: var(--spacing-md);
      width: 350px;
      max-height: 400px;
      background-color: var(--color-surface);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-lg);
      overflow-y: auto;
      z-index: 1100;
    }
    
    .search-result {
      display: flex;
      flex-direction: column;
      padding: var(--spacing-md);
      cursor: pointer;
      border-bottom: 1px solid var(--color-border-light);
      transition: background-color var(--transition-fast);
    }
    
    .search-result:last-child {
      border-bottom: none;
    }
    
    .search-result:hover,
    .search-result.selected {
      background-color: var(--color-hover);
    }
    
    .search-result.selected {
      background-color: var(--color-primary);
      color: var(--color-text-inverse);
    }
    
    .result-label {
      font-size: var(--font-size-base);
      font-weight: var(--font-weight-medium);
      color: var(--color-text);
      margin-bottom: var(--spacing-xs);
    }
    
    .search-result.selected .result-label {
      color: var(--color-text-inverse);
    }
    
    .result-section {
      font-size: var(--font-size-sm);
      color: var(--color-text-secondary);
    }
    
    .search-result.selected .result-section {
      color: var(--color-text-inverse);
      opacity: 0.9;
    }
    
    .search-no-results {
      padding: var(--spacing-lg);
      text-align: center;
      color: var(--color-text-secondary);
      font-size: var(--font-size-sm);
    }
    
    .search-highlight {
      background-color: var(--color-warning);
      color: var(--color-text);
      padding: 2px 4px;
      border-radius: var(--border-radius-sm);
      animation: highlight-fade 2s ease-out;
    }
    
    @keyframes highlight-fade {
      0% {
        background-color: var(--color-warning);
      }
      100% {
        background-color: transparent;
      }
    }
    
    /* ===== Form Styles (Task 4) ===== */
    
    .config-form {
      background-color: var(--color-surface);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius);
      padding: var(--spacing-lg);
      margin-bottom: var(--spacing-lg);
      box-shadow: var(--shadow-sm);
    }
    
    .form-group {
      margin-bottom: var(--spacing-lg);
    }
    
    .form-group label {
      display: block;
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      color: var(--color-text);
      margin-bottom: var(--spacing-sm);
    }
    
    .form-group label .required {
      color: var(--color-danger);
      margin-left: var(--spacing-xs);
    }
    
    .form-group input[type="text"],
    .form-group input[type="email"],
    .form-group input[type="password"],
    .form-group input[type="url"],
    .form-group input[type="tel"],
    .form-group input[type="number"],
    .form-group select,
    .form-group textarea {
      width: 100%;
      padding: var(--spacing-sm) var(--spacing-md);
      font-size: var(--font-size-base);
      font-family: var(--font-family);
      color: var(--color-text);
      background-color: var(--color-bg);
      border: 1px solid var(--color-border);
      border-radius: var(--border-radius-sm);
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
    }
    
    .form-group input:focus,
    .form-group select:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
    }
    
    .form-group input.invalid,
    .form-group select.invalid,
    .form-group textarea.invalid {
      border-color: var(--color-danger);
    }
    
    .form-group input.invalid:focus,
    .form-group select.invalid:focus,
    .form-group textarea.invalid:focus {
      box-shadow: 0 0 0 3px rgba(220, 53, 69, 0.1);
    }
    
    .form-group textarea {
      min-height: 100px;
      resize: vertical;
    }
    
    .form-group input[type="checkbox"],
    .form-group input[type="radio"] {
      width: auto;
      margin-right: var(--spacing-sm);
    }
    
    .error-message {
      display: block;
      font-size: var(--font-size-sm);
      color: var(--color-danger);
      margin-top: var(--spacing-xs);
    }
    
    .form-help {
      display: block;
      font-size: var(--font-size-sm);
      color: var(--color-text-secondary);
      margin-top: var(--spacing-xs);
    }
    
    .form-actions {
      display: flex;
      gap: var(--spacing-md);
      margin-top: var(--spacing-xl);
      padding-top: var(--spacing-lg);
      border-top: 1px solid var(--color-border);
    }
    
    /* ===== Button Styles ===== */
    
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-sm);
      padding: var(--spacing-sm) var(--spacing-lg);
      font-size: var(--font-size-base);
      font-weight: var(--font-weight-medium);
      font-family: var(--font-family);
      color: var(--color-text-inverse);
      background-color: var(--color-primary);
      border: none;
      border-radius: var(--border-radius-sm);
      cursor: pointer;
      transition: background-color var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast);
      user-select: none;
      min-height: 40px;
    }
    
    .btn:hover:not(:disabled) {
      background-color: var(--color-primary-dark);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }
    
    .btn:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: var(--shadow-sm);
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    
    .btn:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.3);
    }
    
    .btn-primary {
      background-color: var(--color-primary);
    }
    
    .btn-primary:hover:not(:disabled) {
      background-color: var(--color-primary-dark);
    }
    
    .btn-secondary {
      background-color: var(--color-text-secondary);
      color: var(--color-text-inverse);
    }
    
    .btn-secondary:hover:not(:disabled) {
      background-color: var(--color-text);
    }
    
    .btn-danger {
      background-color: var(--color-danger);
    }
    
    .btn-danger:hover:not(:disabled) {
      background-color: #c82333;
    }
    
    .btn-warning {
      background-color: var(--color-warning);
      color: var(--color-text);
    }
    
    .btn-warning:hover:not(:disabled) {
      background-color: #e0a800;
    }
    
    .btn-info {
      background-color: var(--color-info);
    }
    
    .btn-info:hover:not(:disabled) {
      background-color: #138496;
    }
    
    .btn-success {
      background-color: var(--color-success);
    }
    
    .btn-success:hover:not(:disabled) {
      background-color: #218838;
    }
    
    .btn-spinner {
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }
    
    .btn-sm {
      padding: var(--spacing-xs) var(--spacing-md);
      font-size: var(--font-size-sm);
      min-height: 32px;
    }
    
    .btn-lg {
      padding: var(--spacing-md) var(--spacing-xl);
      font-size: var(--font-size-lg);
      min-height: 48px;
    }
    
    /* ===== Dashboard Styles (Task 6) ===== */
    
    .dashboard-info-card {
      padding: var(--spacing-md);
      background-color: var(--color-bg);
      border-radius: var(--border-radius);
      border: 1px solid var(--color-border);
      transition: box-shadow var(--transition-fast);
    }
    
    .dashboard-info-card:hover {
      box-shadow: var(--shadow-md);
    }
    
    .dashboard-info-label {
      font-size: var(--font-size-sm);
      color: var(--color-text-secondary);
      margin-bottom: var(--spacing-xs);
    }
    
    .dashboard-info-value {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-bold);
      color: var(--color-text);
    }
    
    .activity-entry {
      padding: var(--spacing-sm);
      border-bottom: 1px solid var(--color-border-light);
      display: flex;
      gap: var(--spacing-sm);
      align-items: start;
      transition: background-color var(--transition-fast);
    }
    
    .activity-entry:last-child {
      border-bottom: none;
    }
    
    .activity-entry:hover {
      background-color: var(--color-hover);
    }
    
    .activity-type {
      font-weight: var(--font-weight-bold);
      min-width: 60px;
      font-size: var(--font-size-sm);
    }
    
    .activity-timestamp {
      color: var(--color-text-secondary);
      font-size: var(--font-size-sm);
      min-width: 80px;
    }
    
    .activity-message {
      flex: 1;
      color: var(--color-text);
      font-size: var(--font-size-sm);
      word-break: break-word;
    }
    
    /* ===== Dialog Styles (Task 4.4) ===== */
    
    .dialog-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 3000;
      opacity: 0;
      transition: opacity var(--transition-base);
    }
    
    .dialog-overlay.show {
      opacity: 1;
    }
    
    .dialog {
      background-color: var(--color-surface);
      border-radius: var(--border-radius-lg);
      box-shadow: var(--shadow-xl);
      max-width: 500px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      transform: scale(0.9);
      transition: transform var(--transition-base);
    }
    
    .dialog-overlay.show .dialog {
      transform: scale(1);
    }
    
    .dialog-header {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      padding: var(--spacing-lg);
      border-bottom: 1px solid var(--color-border);
    }
    
    .dialog-icon {
      font-size: var(--font-size-2xl);
      flex-shrink: 0;
    }
    
    .dialog-title {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-bold);
      color: var(--color-text);
      margin: 0;
    }
    
    .dialog-body {
      padding: var(--spacing-lg);
    }
    
    .dialog-message {
      font-size: var(--font-size-base);
      color: var(--color-text);
      line-height: 1.6;
      margin: 0;
    }
    
    .dialog-footer {
      display: flex;
      gap: var(--spacing-md);
      justify-content: flex-end;
      padding: var(--spacing-lg);
      border-top: 1px solid var(--color-border);
    }
    
    .dialog-warning .dialog-icon {
      color: var(--color-warning);
    }
    
    .dialog-danger .dialog-icon {
      color: var(--color-danger);
    }
    
    /* ===== Responsive Design (Task 2.4) ===== */
    
    /* Mobile: < 768px */
    @media (max-width: 767px) {
      .menu-toggle {
        display: block;
      }
      
      .app-title {
        font-size: var(--font-size-base);
      }
      
      .version {
        display: none;
      }
      
      .sidebar {
        transform: translateX(-100%);
        box-shadow: none;
      }
      
      .sidebar.open {
        transform: translateX(0);
        box-shadow: var(--shadow-xl);
      }
      
      .main-content {
        margin-left: 0;
        padding: var(--spacing-md);
      }
      
      .status-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: var(--spacing-sm);
        padding: var(--spacing-md);
      }
      
      .status-card {
        padding: var(--spacing-sm);
      }
      
      .status-icon {
        font-size: var(--font-size-xl);
      }
      
      .status-label {
        font-size: var(--font-size-xs);
      }
      
      .status-value {
        font-size: var(--font-size-sm);
      }
      
      .toast-container {
        left: var(--spacing-sm);
        right: var(--spacing-sm);
        max-width: none;
      }
      
      .search-results {
        left: var(--spacing-sm);
        right: var(--spacing-sm);
        width: auto;
        top: var(--header-height);
      }
      
      .global-search {
        display: block;
        width: 100%;
        max-width: 200px;
      }
      
      /* Touch-friendly button sizes (minimum 44x44px) */
      .nav-item {
        min-height: 44px;
        padding: var(--spacing-sm) var(--spacing-md);
      }
      
      .status-toggle {
        min-height: 44px;
      }
    }
    
    /* Tablet: 768px - 1024px */
    @media (min-width: 768px) and (max-width: 1024px) {
      .sidebar {
        width: 200px;
      }
      
      .main-content {
        margin-left: 200px;
      }
      
      .nav-item {
        padding: var(--spacing-sm) var(--spacing-md);
      }
      
      .nav-label {
        font-size: var(--font-size-sm);
      }
      
      .global-search {
        width: 180px;
      }
      
      .status-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    
    /* Desktop: > 1024px */
    @media (min-width: 1025px) {
      .status-grid {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    /* Large Desktop: > 1440px */
    @media (min-width: 1441px) {
      .main-content {
        max-width: 1400px;
        margin-left: auto;
        margin-right: auto;
        padding-left: calc(var(--sidebar-width) + var(--spacing-xl));
        padding-right: var(--spacing-xl);
      }
    }
    
    /* Mobile Overlay for Sidebar */
    @media (max-width: 767px) {
      .sidebar.open::before {
        content: '';
        position: fixed;
        top: var(--header-height);
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: -1;
      }
    }
    
    /* Reduced Motion Support */
    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
    
    /* High Contrast Mode Support */
    @media (prefers-contrast: high) {
      .status-card {
        border-width: 3px;
      }
      
      .nav-item.active {
        outline: 2px solid var(--color-text-inverse);
        outline-offset: -2px;
      }
    }
    
    /* Print Styles */
    @media print {
      .app-header,
      .sidebar,
      .status-panel,
      .toast-container {
        display: none;
      }
      
      .main-content {
        margin: 0;
        padding: 0;
      }
    }
  </style>
</head>
<body>
  
  <!-- Header -->
  <header class="app-header">
    <button class="menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false" aria-controls="sidebar">
      ☰
    </button>
    <h1 class="app-title">ESP32 SIP Door Station</h1>
    <div class="header-actions">
      <input type="search" 
             class="global-search" 
             id="global-search"
             placeholder="Search settings... (Ctrl+K)"
             autocomplete="off"
             aria-label="Search settings">
      <button class="theme-toggle" aria-label="Toggle theme" id="theme-toggle">
        🌙
      </button>
      <span class="version">v1.0</span>
    </div>
  </header>

  <!-- Sidebar Navigation -->
  <nav class="sidebar" id="sidebar" role="navigation" aria-label="Main navigation">
    <ul class="nav-menu">
      <li class="nav-item active" data-section="dashboard">
        <span class="nav-icon">🏠</span>
        <span class="nav-label">Dashboard</span>
        <span class="unsaved-indicator" hidden>●</span>
      </li>
      <li class="nav-item" data-section="sip">
        <span class="nav-icon">📞</span>
        <span class="nav-label">SIP Settings</span>
        <span class="unsaved-indicator" hidden>●</span>
      </li>
      <li class="nav-item" data-section="network">
        <span class="nav-icon">🌐</span>
        <span class="nav-label">Network</span>
        <span class="unsaved-indicator" hidden>●</span>
      </li>
      <li class="nav-item" data-section="hardware">
        <span class="nav-icon">⚙️</span>
        <span class="nav-label">Hardware</span>
        <span class="unsaved-indicator" hidden>●</span>
      </li>
      <li class="nav-item" data-section="security">
        <span class="nav-icon">🔒</span>
        <span class="nav-label">Security</span>
        <span class="unsaved-indicator" hidden>●</span>
      </li>
      <li class="nav-item" data-section="logs">
        <span class="nav-icon">📋</span>
        <span class="nav-label">System Logs</span>
        <span class="unsaved-indicator" hidden>●</span>
      </li>
      <li class="nav-item" data-section="testing">
        <span class="nav-icon">🧪</span>
        <span class="nav-label">Hardware Testing</span>
        <span class="unsaved-indicator" hidden>●</span>
      </li>
      <li class="nav-item" data-section="email">
        <span class="nav-icon">📧</span>
        <span class="nav-label">Email Reports</span>
        <span class="unsaved-indicator" hidden>●</span>
      </li>
      <li class="nav-item" data-section="ota">
        <span class="nav-icon">🔄</span>
        <span class="nav-label">OTA Update</span>
        <span class="unsaved-indicator" hidden>●</span>
      </li>
      <li class="nav-item" data-section="docs">
        <span class="nav-icon">📖</span>
        <span class="nav-label">Documentation</span>
        <span class="unsaved-indicator" hidden>●</span>
      </li>
    </ul>
  </nav>

  <!-- Main Content Area -->
  <main class="main-content" id="main-content">
    
    <!-- Status Panel (Collapsible) -->
    <div class="status-panel" id="status-panel">
      <button class="status-toggle" aria-label="Toggle status panel" aria-expanded="true" aria-controls="status-content">
        <span>Status</span>
        <span class="toggle-icon">▼</span>
      </button>
      <div class="status-content" id="status-content">
        <div class="status-grid">
          <div class="status-card" id="wifi-status" data-status="disconnected" role="status" aria-live="polite" aria-label="WiFi connection status">
            <span class="status-icon">📶</span>
            <div class="status-info">
              <span class="status-label">WiFi</span>
              <span class="status-value">Disconnected</span>
            </div>
          </div>
          <div class="status-card" id="sip-status" data-status="disconnected" role="status" aria-live="polite" aria-label="SIP connection status">
            <span class="status-icon">📞</span>
            <div class="status-info">
              <span class="status-label">SIP</span>
              <span class="status-value">Disconnected</span>
            </div>
          </div>
          <div class="status-card" id="door-status" data-status="closed" role="status" aria-live="polite" aria-label="Door status">
            <span class="status-icon">🚪</span>
            <div class="status-info">
              <span class="status-label">Door</span>
              <span class="status-value">Closed</span>
            </div>
          </div>
          <div class="status-card" id="light-status" data-status="off" role="status" aria-live="polite" aria-label="Light status">
            <span class="status-icon">💡</span>
            <div class="status-info">
              <span class="status-label">Light</span>
              <span class="status-value">Off</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Dashboard Section -->
    <section class="content-section active" id="section-dashboard">
      <h2 tabindex="-1">Dashboard</h2>
      
      <!-- System Information Display (Task 6.1) -->
      <div class="config-form">
        <h3 style="margin-bottom: var(--spacing-md);">System Information</h3>
        <div id="system-info" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: var(--spacing-md);">
          <div style="padding: var(--spacing-md); background-color: var(--color-bg); border-radius: var(--border-radius); border: 1px solid var(--color-border);">
            <div style="font-size: var(--font-size-sm); color: var(--color-text-secondary); margin-bottom: var(--spacing-xs);">Uptime</div>
            <div id="system-uptime" style="font-size: var(--font-size-lg); font-weight: var(--font-weight-bold); color: var(--color-text);">Loading...</div>
          </div>
          <div style="padding: var(--spacing-md); background-color: var(--color-bg); border-radius: var(--border-radius); border: 1px solid var(--color-border);">
            <div style="font-size: var(--font-size-sm); color: var(--color-text-secondary); margin-bottom: var(--spacing-xs);">Free Heap</div>
            <div id="system-heap" style="font-size: var(--font-size-lg); font-weight: var(--font-weight-bold); color: var(--color-text);">Loading...</div>
          </div>
          <div style="padding: var(--spacing-md); background-color: var(--color-bg); border-radius: var(--border-radius); border: 1px solid var(--color-border);">
            <div style="font-size: var(--font-size-sm); color: var(--color-text-secondary); margin-bottom: var(--spacing-xs);">IP Address</div>
            <div id="system-ip" style="font-size: var(--font-size-lg); font-weight: var(--font-weight-bold); color: var(--color-text);">Loading...</div>
          </div>
          <div style="padding: var(--spacing-md); background-color: var(--color-bg); border-radius: var(--border-radius); border: 1px solid var(--color-border);">
            <div style="font-size: var(--font-size-sm); color: var(--color-text-secondary); margin-bottom: var(--spacing-xs);">Firmware Version</div>
            <div id="system-version" style="font-size: var(--font-size-lg); font-weight: var(--font-weight-bold); color: var(--color-text);">Loading...</div>
          </div>
        </div>
      </div>
      
      <!-- NTP Sync Status (Task 6.3) -->
      <div class="config-form">
        <h3 style="margin-bottom: var(--spacing-md);">Time Synchronization</h3>
        <div id="ntp-status" style="display: flex; align-items: center; gap: var(--spacing-lg); flex-wrap: wrap;">
          <div style="flex: 1; min-width: 200px;">
            <div style="font-size: var(--font-size-sm); color: var(--color-text-secondary); margin-bottom: var(--spacing-xs);">NTP Sync Status</div>
            <div style="display: flex; align-items: center; gap: var(--spacing-sm);">
              <span id="ntp-sync-indicator" style="font-size: var(--font-size-xl);">⏳</span>
              <span id="ntp-sync-text" style="font-size: var(--font-size-base); font-weight: var(--font-weight-medium); color: var(--color-text);">Checking...</span>
            </div>
          </div>
          <div style="flex: 1; min-width: 200px;">
            <div style="font-size: var(--font-size-sm); color: var(--color-text-secondary); margin-bottom: var(--spacing-xs);">Current Time</div>
            <div id="ntp-current-time" style="font-size: var(--font-size-base); font-weight: var(--font-weight-medium); color: var(--color-text);">Loading...</div>
          </div>
        </div>
      </div>
      
      <!-- Quick Actions (Task 6.2) -->
      <div class="config-form">
        <h3 style="margin-bottom: var(--spacing-md);">Quick Actions</h3>
        <p style="margin-bottom: var(--spacing-lg); color: var(--color-text-secondary);">
          Perform common system actions. Destructive actions will require confirmation.
        </p>
        
        <div style="display: flex; gap: var(--spacing-md); flex-wrap: wrap;">
          <button class="btn btn-success" onclick="handleSIPConnect()" id="quick-sip-connect">
            <span>📞</span>
            <span>Connect SIP</span>
          </button>
          <button class="btn btn-warning" onclick="handleSIPDisconnect()" id="quick-sip-disconnect">
            <span>📴</span>
            <span>Disconnect SIP</span>
          </button>
          <button class="btn btn-warning" onclick="handleSystemRestart()" id="system-restart-btn">
            <span>🔄</span>
            <span>Restart System</span>
          </button>
          <button class="btn btn-danger" onclick="handleFactoryReset()" id="factory-reset-btn">
            <span>⚠️</span>
            <span>Factory Reset</span>
          </button>
        </div>
      </div>
      
      <!-- Recent Activity Summary (Task 6.4) -->
      <div class="config-form">
        <h3 style="margin-bottom: var(--spacing-md);">Recent Activity</h3>
        <div id="recent-activity" style="max-height: 300px; overflow-y: auto; background-color: var(--color-bg); border: 1px solid var(--color-border); border-radius: var(--border-radius); padding: var(--spacing-md);">
          <div style="text-align: center; color: var(--color-text-secondary); padding: var(--spacing-lg);">Loading recent activity...</div>
        </div>
      </div>
      
      <!-- Backup/Restore Functionality (Task 6.5) -->
      <div class="config-form">
        <h3 style="margin-bottom: var(--spacing-md);">Configuration Backup & Restore</h3>
        <p style="margin-bottom: var(--spacing-lg); color: var(--color-text-secondary);">
          Backup your configuration to a JSON file or restore from a previous backup.
        </p>
        
        <div style="display: flex; gap: var(--spacing-md); flex-wrap: wrap; margin-bottom: var(--spacing-lg);">
          <button class="btn btn-primary" onclick="handleBackupConfig()">
            <span>💾</span>
            <span>Download Backup</span>
          </button>
          <button class="btn btn-info" onclick="document.getElementById('restore-file-input').click()">
            <span>📂</span>
            <span>Restore from File</span>
          </button>
          <input type="file" id="restore-file-input" accept=".json" style="display: none;" onchange="handleRestoreFileSelected(event)">
        </div>
        
        <div class="form-group" style="margin-bottom: 0;">
          <label>
            <input type="checkbox" id="backup-include-passwords" checked>
            Include passwords in backup (recommended for security: uncheck)
          </label>
          <span class="form-help">Unchecking this will exclude sensitive passwords from the backup file</span>
        </div>
      </div>
    </section>

    <!-- SIP Settings Section (Task 7) -->
    <section class="content-section" id="section-sip" hidden>
      <h2 tabindex="-1">SIP Settings</h2>
      
      <!-- Task 7.1: SIP Configuration Form -->
      <form class="config-form" id="sip-form" data-api="/api/sip/config">
        <h3 style="margin-bottom: var(--spacing-md);">SIP Server Configuration</h3>
        <p style="margin-bottom: var(--spacing-lg); color: var(--color-text-secondary);">
          Configure your SIP server connection and call targets. All fields marked with * are required.
        </p>
        
        <div class="form-group">
          <label for="sip-server">
            SIP Server
            <span class="required">*</span>
          </label>
          <input 
            type="text" 
            id="sip-server" 
            name="server" 
            required
            pattern="^[a-zA-Z0-9.-]+$"
            data-error="Please enter a valid server address (letters, numbers, dots, and hyphens only)"
            placeholder="sip.example.com">
          <span class="error-message" hidden></span>
          <span class="form-help">Enter your SIP server domain or IP address</span>
        </div>
        
        <div class="form-group">
          <label for="sip-username">
            Username
            <span class="required">*</span>
          </label>
          <input 
            type="text" 
            id="sip-username" 
            name="username" 
            required
            minlength="3"
            data-error="Username must be at least 3 characters"
            placeholder="doorstation">
          <span class="error-message" hidden></span>
          <span class="form-help">SIP account username for authentication</span>
        </div>
        
        <div class="form-group">
          <label for="sip-password">
            Password
            <span class="required">*</span>
          </label>
          <input 
            type="password" 
            id="sip-password" 
            name="password" 
            required
            minlength="6"
            data-error="Password must be at least 6 characters"
            placeholder="••••••••">
          <span class="error-message" hidden></span>
          <span class="form-help">SIP account password for authentication</span>
        </div>
        
        <div class="form-group">
          <label for="sip-target1">
            Target 1 (Apartment 1)
            <span class="required">*</span>
          </label>
          <input 
            type="text" 
            id="sip-target1" 
            name="target1" 
            required
            pattern="^sip:[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+$"
            data-error="Please enter a valid SIP URI (e.g., sip:user@domain.com)"
            placeholder="sip:apartment1@example.com">
          <span class="error-message" hidden></span>
          <span class="form-help">SIP URI to call when doorbell button 1 is pressed</span>
        </div>
        
        <div class="form-group">
          <label for="sip-target2">
            Target 2 (Apartment 2)
          </label>
          <input 
            type="text" 
            id="sip-target2" 
            name="target2" 
            pattern="^sip:[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+$"
            data-error="Please enter a valid SIP URI (e.g., sip:user@domain.com)"
            placeholder="sip:apartment2@example.com">
          <span class="error-message" hidden></span>
          <span class="form-help">Optional second target for dual apartment setup (doorbell button 2)</span>
        </div>
        
        <div class="form-actions">
          <button type="submit" class="btn btn-primary" disabled>
            <span class="btn-text">Save Configuration</span>
            <span class="btn-spinner" hidden>⏳</span>
          </button>
          <button type="reset" class="btn btn-secondary">Reset</button>
        </div>
      </form>
      
      <!-- Task 7.2: Test Call Buttons -->
      <div class="config-form" style="margin-top: var(--spacing-lg);">
        <h3 style="margin-bottom: var(--spacing-md);">Test Calls</h3>
        <p style="margin-bottom: var(--spacing-lg); color: var(--color-text-secondary);">
          Test your SIP configuration by initiating a test call to each target. Make sure you have saved your configuration first.
        </p>
        
        <div style="display: flex; gap: var(--spacing-md); flex-wrap: wrap;">
          <button class="btn btn-info" onclick="handleTestCall(1)" id="test-call-target1">
            <span class="btn-text">
              <span>📞</span>
              <span>Test Call Target 1</span>
            </span>
            <span class="btn-spinner" hidden>⏳</span>
          </button>
          <button class="btn btn-info" onclick="handleTestCall(2)" id="test-call-target2">
            <span class="btn-text">
              <span>📞</span>
              <span>Test Call Target 2</span>
            </span>
            <span class="btn-spinner" hidden>⏳</span>
          </button>
        </div>
        
        <div id="test-call-feedback" style="margin-top: var(--spacing-md); padding: var(--spacing-md); background-color: var(--color-bg); border-radius: var(--border-radius); border: 1px solid var(--color-border); display: none;">
          <div style="display: flex; align-items: center; gap: var(--spacing-sm);">
            <span id="test-call-icon" style="font-size: var(--font-size-xl);"></span>
            <span id="test-call-message" style="font-size: var(--font-size-base); color: var(--color-text);"></span>
          </div>
        </div>
      </div>
      
      <!-- Task 7.3: Connection Management -->
      <div class="config-form" style="margin-top: var(--spacing-lg);">
        <h3 style="margin-bottom: var(--spacing-md);">Connection Management</h3>
        <p style="margin-bottom: var(--spacing-lg); color: var(--color-text-secondary);">
          Manage your SIP server connection. You must be connected to receive incoming calls.
        </p>
        
        <div style="display: flex; gap: var(--spacing-md); flex-wrap: wrap; margin-bottom: var(--spacing-lg);">
          <button class="btn btn-success" onclick="handleSIPConnectEnhanced()" id="sip-connect-btn">
            <span class="btn-text">
              <span>📞</span>
              <span>Connect to SIP</span>
            </span>
            <span class="btn-spinner" hidden>⏳</span>
          </button>
          <button class="btn btn-warning" onclick="handleSIPDisconnectEnhanced()" id="sip-disconnect-btn">
            <span class="btn-text">
              <span>📴</span>
              <span>Disconnect</span>
            </span>
            <span class="btn-spinner" hidden>⏳</span>
          </button>
          <button class="btn btn-info" onclick="handleSIPTestEnhanced()" id="sip-test-btn">
            <span class="btn-text">
              <span>🧪</span>
              <span>Test Configuration</span>
            </span>
            <span class="btn-spinner" hidden>⏳</span>
          </button>
        </div>
        
        <!-- Connection Status Display -->
        <div style="padding: var(--spacing-md); background-color: var(--color-bg); border-radius: var(--border-radius); border: 1px solid var(--color-border);">
          <div style="font-size: var(--font-size-sm); color: var(--color-text-secondary); margin-bottom: var(--spacing-xs);">Current Connection Status</div>
          <div style="display: flex; align-items: center; gap: var(--spacing-sm);">
            <span id="sip-connection-icon" style="font-size: var(--font-size-xl);">⏳</span>
            <span id="sip-connection-status" style="font-size: var(--font-size-base); font-weight: var(--font-weight-medium); color: var(--color-text);">Checking...</span>
          </div>
        </div>
      </div>
    </section>

    <!-- Network Settings Section -->
    <section class="content-section" id="section-network" hidden>
      <h2 tabindex="-1">Network Settings</h2>
      <p>Network configuration will be implemented here.</p>
    </section>

    <!-- Hardware Settings Section -->
    <section class="content-section" id="section-hardware" hidden>
      <h2 tabindex="-1">Hardware Settings</h2>
      <p>Hardware information will be implemented here.</p>
    </section>

    <!-- Security Settings Section -->
    <section class="content-section" id="section-security" hidden>
      <h2 tabindex="-1">Security Settings</h2>
      <p>Security configuration will be implemented here.</p>
    </section>

    <!-- System Logs Section -->
    <section class="content-section" id="section-logs" hidden>
      <h2 tabindex="-1">System Logs</h2>
      <p>System logs will be implemented here.</p>
    </section>

    <!-- Hardware Testing Section -->
    <section class="content-section" id="section-testing" hidden>
      <h2 tabindex="-1">Hardware Testing</h2>
      <p>Hardware testing controls will be implemented here.</p>
    </section>

    <!-- Email Reports Section -->
    <section class="content-section" id="section-email" hidden>
      <h2 tabindex="-1">Email Reports</h2>
      <p>Email configuration will be implemented here.</p>
    </section>

    <!-- OTA Update Section -->
    <section class="content-section" id="section-ota" hidden>
      <h2 tabindex="-1">OTA Update</h2>
      <p>OTA update interface will be implemented here.</p>
    </section>

    <!-- Documentation Section -->
    <section class="content-section" id="section-docs" hidden>
      <h2 tabindex="-1">Documentation</h2>
      <p>Documentation will be implemented here.</p>
    </section>

  </main>

  <!-- Toast Notification Container -->
  <div class="toast-container" id="toast-container" aria-live="polite" aria-atomic="true"></div>

  <!-- Search Results Dropdown -->
  <div class="search-results" id="search-results" hidden role="listbox"></div>

  <script>
    // ===== Task 3: Core JavaScript Functionality =====
    
    // ===== Task 3.1: Navigation System =====
    
    /**
     * Navigate to a specific section
     * @param {string} sectionId - The section identifier (e.g., 'dashboard', 'sip')
     */
    function navigateToSection(sectionId) {
      // Hide all sections
      document.querySelectorAll('.content-section').forEach(section => {
        section.hidden = true;
        section.classList.remove('active');
      });
      
      // Show selected section with fade-in
      const targetSection = document.getElementById(`section-${sectionId}`);
      if (targetSection) {
        targetSection.hidden = false;
        // Small delay to trigger CSS transition
        setTimeout(() => targetSection.classList.add('active'), 10);
        
        // Scroll to top of main content
        document.getElementById('main-content').scrollTop = 0;
        
        // Set focus to section heading for accessibility
        const heading = targetSection.querySelector('h2');
        if (heading) {
          heading.focus();
        }
      }
      
      // Update sidebar active state
      document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.toggle('active', item.dataset.section === sectionId);
        item.setAttribute('aria-current', item.dataset.section === sectionId ? 'page' : 'false');
      });
      
      // Save to sessionStorage for persistence
      sessionStorage.setItem('activeSection', sectionId);
      
      // Close mobile sidebar after navigation
      if (window.innerWidth < 768) {
        closeMobileSidebar();
      }
      
      // Section-specific initialization (Task 7.3, 7.4)
      if (sectionId === 'sip') {
        // Load SIP configuration from server (Task 7.4)
        loadSIPConfiguration();
        // Update SIP connection status and button states
        updateSIPConnectionStatus();
      }
    }
    
    /**
     * Initialize navigation system
     */
    function initNavigation() {
      // Add click handlers to nav items
      document.querySelectorAll('.nav-item').forEach(item => {
        item.addEventListener('click', () => {
          const section = item.dataset.section;
          if (section) {
            navigateToSection(section);
          }
        });
        
        // Keyboard navigation support
        item.setAttribute('tabindex', '0');
        item.setAttribute('role', 'button');
        item.setAttribute('aria-current', 'false');
        
        item.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            const section = item.dataset.section;
            if (section) {
              navigateToSection(section);
            }
          }
        });
      });
      
      // Arrow key navigation in sidebar
      const navItems = Array.from(document.querySelectorAll('.nav-item'));
      navItems.forEach((item, index) => {
        item.addEventListener('keydown', (e) => {
          let targetIndex = -1;
          
          if (e.key === 'ArrowDown') {
            e.preventDefault();
            targetIndex = (index + 1) % navItems.length;
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            targetIndex = (index - 1 + navItems.length) % navItems.length;
          }
          
          if (targetIndex >= 0) {
            navItems[targetIndex].focus();
          }
        });
      });
      
      // Restore last active section from sessionStorage
      const savedSection = sessionStorage.getItem('activeSection');
      if (savedSection) {
        navigateToSection(savedSection);
      }
    }
    
    /**
     * Close mobile sidebar
     */
    function closeMobileSidebar() {
      const sidebar = document.getElementById('sidebar');
      const menuToggle = document.querySelector('.menu-toggle');
      sidebar.classList.remove('open');
      if (menuToggle) {
        menuToggle.setAttribute('aria-expanded', 'false');
      }
    }
    
    /**
     * Toggle mobile sidebar
     */
    function toggleMobileSidebar() {
      const sidebar = document.getElementById('sidebar');
      const menuToggle = document.querySelector('.menu-toggle');
      const isOpen = sidebar.classList.toggle('open');
      if (menuToggle) {
        menuToggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
      }
    }
    
    // ===== Task 3.2: Theme Toggle Functionality =====
    
    /**
     * Initialize theme system
     */
    function initTheme() {
      // Check localStorage first
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme) {
        document.documentElement.setAttribute('data-theme', savedTheme);
        updateThemeIcon(savedTheme);
        return;
      }
      
      // Check system preference
      if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.documentElement.setAttribute('data-theme', 'dark');
        updateThemeIcon('dark');
      } else {
        updateThemeIcon('light');
      }
    }
    
    /**
     * Toggle between light and dark theme
     */
    function toggleTheme() {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
      updateThemeIcon(newTheme);
    }
    
    /**
     * Update theme toggle button icon
     * @param {string} theme - Current theme ('light' or 'dark')
     */
    function updateThemeIcon(theme) {
      const themeToggle = document.getElementById('theme-toggle');
      if (themeToggle) {
        themeToggle.textContent = theme === 'dark' ? '☀️' : '🌙';
        themeToggle.setAttribute('aria-label', `Switch to ${theme === 'dark' ? 'light' : 'dark'} theme`);
      }
    }
    
    // ===== Task 3.3: Status Panel Functionality =====
    
    /**
     * Toggle status panel collapse/expand
     */
    function toggleStatusPanel() {
      const panel = document.getElementById('status-panel');
      const toggle = panel.querySelector('.status-toggle');
      const isCollapsed = panel.classList.toggle('collapsed');
      
      // Update ARIA attributes
      toggle.setAttribute('aria-expanded', !isCollapsed);
      
      // Save state to localStorage
      localStorage.setItem('statusPanelCollapsed', isCollapsed);
    }
    
    /**
     * Initialize status panel
     */
    function initStatusPanel() {
      // Restore collapsed state from localStorage
      const isCollapsed = localStorage.getItem('statusPanelCollapsed') === 'true';
      const panel = document.getElementById('status-panel');
      const toggle = panel.querySelector('.status-toggle');
      
      if (isCollapsed) {
        panel.classList.add('collapsed');
        toggle.setAttribute('aria-expanded', 'false');
      }
      
      // Add click handler
      toggle.addEventListener('click', toggleStatusPanel);
      
      // Start auto-refresh
      updateAllStatus();
      setInterval(updateAllStatus, 10000); // Update every 10 seconds
    }
    
    /**
     * Update all status cards
     */
    async function updateAllStatus() {
      try {
        await Promise.all([
          updateWiFiStatus(),
          updateSIPStatus(),
          updateDoorStatus(),
          updateLightStatus()
        ]);
      } catch (error) {
        console.error('Error updating status:', error);
      }
    }
    
    /**
     * Update WiFi status card
     */
    async function updateWiFiStatus() {
      try {
        const response = await apiRequest('/api/wifi/status');
        const card = document.getElementById('wifi-status');
        const valueSpan = card.querySelector('.status-value');
        
        if (response.status === 'connected') {
          card.setAttribute('data-status', 'connected');
          valueSpan.textContent = `Connected (${response.ip || 'N/A'})`;
        } else if (response.status === 'connecting') {
          card.setAttribute('data-status', 'connecting');
          valueSpan.textContent = 'Connecting...';
        } else {
          card.setAttribute('data-status', 'disconnected');
          valueSpan.textContent = 'Disconnected';
        }
      } catch (error) {
        const card = document.getElementById('wifi-status');
        card.setAttribute('data-status', 'disconnected');
        card.querySelector('.status-value').textContent = 'Error';
      }
    }
    
    /**
     * Update SIP status card
     */
    async function updateSIPStatus() {
      try {
        const response = await apiRequest('/api/sip/status');
        const card = document.getElementById('sip-status');
        const valueSpan = card.querySelector('.status-value');
        
        // API returns capitalized status values like "Registered", "Connecting", etc.
        const status = response.status ? response.status.toLowerCase() : '';
        
        if (status === 'registered') {
          card.setAttribute('data-status', 'registered');
          valueSpan.textContent = `Registered (${response.state || 'IDLE'})`;
        } else if (status === 'connecting') {
          card.setAttribute('data-status', 'connecting');
          valueSpan.textContent = 'Connecting...';
        } else {
          card.setAttribute('data-status', 'disconnected');
          valueSpan.textContent = response.status || 'Disconnected';
        }
      } catch (error) {
        const card = document.getElementById('sip-status');
        card.setAttribute('data-status', 'disconnected');
        card.querySelector('.status-value').textContent = 'Error';
      }
    }
    
    /**
     * Update door status card
     */
    async function updateDoorStatus() {
      try {
        const response = await apiRequest('/api/hardware/status');
        const card = document.getElementById('door-status');
        const valueSpan = card.querySelector('.status-value');
        
        if (response.door && response.door.status === 'open') {
          card.setAttribute('data-status', 'open');
          valueSpan.textContent = 'Open';
        } else {
          card.setAttribute('data-status', 'closed');
          valueSpan.textContent = 'Closed';
        }
      } catch (error) {
        const card = document.getElementById('door-status');
        card.setAttribute('data-status', 'closed');
        card.querySelector('.status-value').textContent = 'Closed';
      }
    }
    
    /**
     * Update light status card
     */
    async function updateLightStatus() {
      try {
        const response = await apiRequest('/api/hardware/status');
        const card = document.getElementById('light-status');
        const valueSpan = card.querySelector('.status-value');
        
        if (response.light && response.light.status === 'on') {
          card.setAttribute('data-status', 'on');
          valueSpan.textContent = 'On';
        } else {
          card.setAttribute('data-status', 'off');
          valueSpan.textContent = 'Off';
        }
      } catch (error) {
        const card = document.getElementById('light-status');
        card.setAttribute('data-status', 'off');
        card.querySelector('.status-value').textContent = 'Off';
      }
    }
    
    // ===== Task 3.4: Toast Notification System =====
    
    let toastQueue = [];
    let isShowingToast = false;
    
    /**
     * Show a toast notification
     * @param {string} message - The message to display
     * @param {string} type - Toast type: 'success', 'error', 'warning', 'info'
     * @param {number} duration - Duration in milliseconds (default: 3000)
     */
    function showToast(message, type = 'info', duration = 3000) {
      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;
      
      const iconMap = {
        success: '✅',
        error: '❌',
        warning: '⚠️',
        info: 'ℹ️'
      };
      const icon = iconMap[type] || iconMap.info;
      
      toast.innerHTML = `
        <span class="toast-icon">${icon}</span>
        <span class="toast-message">${message}</span>
        <button class="toast-close" aria-label="Close notification">×</button>
      `;
      
      const container = document.getElementById('toast-container');
      container.appendChild(toast);
      
      // Animate in
      setTimeout(() => toast.classList.add('show'), 10);
      
      // Auto-remove
      const autoRemoveTimeout = setTimeout(() => {
        removeToast(toast);
      }, duration);
      
      // Manual close
      const closeBtn = toast.querySelector('.toast-close');
      closeBtn.addEventListener('click', () => {
        clearTimeout(autoRemoveTimeout);
        removeToast(toast);
      });
    }
    
    /**
     * Remove a toast notification
     * @param {HTMLElement} toast - The toast element to remove
     */
    function removeToast(toast) {
      toast.classList.remove('show');
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 300);
    }
    
    /**
     * Queue a toast notification
     * @param {string} message - The message to display
     * @param {string} type - Toast type
     * @param {number} duration - Duration in milliseconds
     */
    function queueToast(message, type = 'info', duration = 3000) {
      toastQueue.push({ message, type, duration });
      if (!isShowingToast) {
        processToastQueue();
      }
    }
    
    /**
     * Process the toast queue
     */
    function processToastQueue() {
      if (toastQueue.length === 0) {
        isShowingToast = false;
        return;
      }
      
      isShowingToast = true;
      const { message, type, duration } = toastQueue.shift();
      showToast(message, type, duration);
      
      setTimeout(processToastQueue, duration + 500);
    }
    
    // ===== Task 3.5: API Request Wrapper =====
    
    /**
     * Make an API request with error handling and timeout
     * @param {string} endpoint - API endpoint URL
     * @param {Object} options - Fetch options
     * @param {number} timeout - Request timeout in milliseconds (default: 10000)
     * @returns {Promise<Object>} Response data
     */
    async function apiRequest(endpoint, options = {}, timeout = 10000) {
      const defaultOptions = {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      };
      
      const config = { ...defaultOptions, ...options };
      
      try {
        // Create timeout promise
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Request timeout')), timeout);
        });
        
        // Race between fetch and timeout
        const response = await Promise.race([
          fetch(endpoint, config),
          timeoutPromise
        ]);
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`);
        }
        
        return await response.json();
      } catch (error) {
        console.error(`API Error [${endpoint}]:`, error);
        
        // Show user-friendly error messages
        if (error.message === 'Request timeout') {
          showToast('Request timed out. Please try again.', 'error');
        } else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
          showToast('Connection error. Please check your network.', 'error');
        } else {
          showToast(error.message, 'error');
        }
        
        throw error;
      }
    }
    
    /**
     * Show loading state on an element
     * @param {HTMLElement} element - Element to show loading state on
     * @param {boolean} isLoading - Whether to show or hide loading state
     */
    function setLoadingState(element, isLoading) {
      if (isLoading) {
        element.disabled = true;
        element.classList.add('loading');
        const spinner = element.querySelector('.btn-spinner');
        const text = element.querySelector('.btn-text');
        if (spinner) spinner.hidden = false;
        if (text) text.hidden = true;
      } else {
        element.disabled = false;
        element.classList.remove('loading');
        const spinner = element.querySelector('.btn-spinner');
        const text = element.querySelector('.btn-text');
        if (spinner) spinner.hidden = true;
        if (text) text.hidden = false;
      }
    }
    
    // ===== Task 4: Form Handling and Validation =====
    
    // Store initial form states for change tracking
    let formInitialStates = {};
    
    // ===== Task 4.1: Form Validation System =====
    
    /**
     * Validate a form using HTML5 validation
     * @param {HTMLFormElement} form - The form to validate
     * @returns {boolean} True if form is valid, false otherwise
     */
    function validateForm(form) {
      let isValid = true;
      const inputs = form.querySelectorAll('input[required], select[required], textarea[required]');
      
      inputs.forEach(input => {
        const errorSpan = input.parentElement.querySelector('.error-message');
        
        // Check HTML5 validity
        if (!input.validity.valid) {
          isValid = false;
          
          // Get custom error message or use default
          let errorMessage = input.dataset.error || 'This field is required';
          
          // Provide specific error messages based on validity state
          if (input.validity.valueMissing) {
            errorMessage = input.dataset.error || 'This field is required';
          } else if (input.validity.typeMismatch) {
            errorMessage = `Please enter a valid ${input.type}`;
          } else if (input.validity.patternMismatch) {
            errorMessage = input.dataset.error || 'Please match the requested format';
          } else if (input.validity.tooShort) {
            errorMessage = `Minimum length is ${input.minLength} characters`;
          } else if (input.validity.tooLong) {
            errorMessage = `Maximum length is ${input.maxLength} characters`;
          } else if (input.validity.rangeUnderflow) {
            errorMessage = `Minimum value is ${input.min}`;
          } else if (input.validity.rangeOverflow) {
            errorMessage = `Maximum value is ${input.max}`;
          }
          
          if (errorSpan) {
            errorSpan.textContent = errorMessage;
            errorSpan.hidden = false;
          }
          input.classList.add('invalid');
          input.setAttribute('aria-invalid', 'true');
        } else {
          if (errorSpan) {
            errorSpan.hidden = true;
          }
          input.classList.remove('invalid');
          input.setAttribute('aria-invalid', 'false');
        }
      });
      
      return isValid;
    }
    
    /**
     * Clear validation errors from a form
     * @param {HTMLFormElement} form - The form to clear errors from
     */
    function clearValidationErrors(form) {
      const inputs = form.querySelectorAll('input, select, textarea');
      inputs.forEach(input => {
        const errorSpan = input.parentElement.querySelector('.error-message');
        if (errorSpan) {
          errorSpan.hidden = true;
        }
        input.classList.remove('invalid');
        input.setAttribute('aria-invalid', 'false');
      });
    }
    
    /**
     * Setup real-time validation for form inputs
     * @param {HTMLFormElement} form - The form to setup validation for
     */
    function setupFormValidation(form) {
      const inputs = form.querySelectorAll('input[required], select[required], textarea[required]');
      
      inputs.forEach(input => {
        // Validate on blur
        input.addEventListener('blur', () => {
          if (input.value) {
            validateForm(form);
          }
        });
        
        // Clear error on input
        input.addEventListener('input', () => {
          if (input.classList.contains('invalid')) {
            const errorSpan = input.parentElement.querySelector('.error-message');
            if (input.validity.valid) {
              if (errorSpan) {
                errorSpan.hidden = true;
              }
              input.classList.remove('invalid');
              input.setAttribute('aria-invalid', 'false');
            }
          }
        });
      });
    }
    
    // ===== Task 4.2: Unsaved Changes Tracking =====
    
    /**
     * Get form data as an object
     * @param {HTMLFormElement} form - The form to get data from
     * @returns {Object} Form data as key-value pairs
     */
    function getFormData(form) {
      const formData = new FormData(form);
      const data = {};
      
      for (const [key, value] of formData.entries()) {
        // Handle checkboxes
        const input = form.elements[key];
        if (input && input.type === 'checkbox') {
          data[key] = input.checked;
        } else {
          data[key] = value;
        }
      }
      
      return data;
    }
    
    /**
     * Track form changes and update UI accordingly
     * @param {HTMLFormElement} form - The form to track changes for
     */
    function trackFormChanges(form) {
      const formId = form.id;
      if (!formId) return;
      
      const currentState = getFormData(form);
      const initialState = formInitialStates[formId] || {};
      
      // Compare current state with initial state
      const hasChanges = JSON.stringify(currentState) !== JSON.stringify(initialState);
      
      // Enable/disable save button
      const saveButton = form.querySelector('button[type="submit"]');
      if (saveButton) {
        saveButton.disabled = !hasChanges;
      }
      
      // Show/hide unsaved indicator in sidebar
      const section = form.closest('.content-section');
      if (section) {
        const sectionId = section.id.replace('section-', '');
        const navItem = document.querySelector(`.nav-item[data-section="${sectionId}"]`);
        if (navItem) {
          const indicator = navItem.querySelector('.unsaved-indicator');
          if (indicator) {
            indicator.hidden = !hasChanges;
          }
        }
      }
    }
    
    /**
     * Save initial form state for change tracking
     * @param {HTMLFormElement} form - The form to save state for
     */
    function saveFormInitialState(form) {
      const formId = form.id;
      if (!formId) return;
      
      formInitialStates[formId] = getFormData(form);
    }
    
    /**
     * Setup change tracking for a form
     * @param {HTMLFormElement} form - The form to setup tracking for
     */
    function setupFormChangeTracking(form) {
      // Save initial state
      saveFormInitialState(form);
      
      // Track changes on input
      form.addEventListener('input', () => {
        trackFormChanges(form);
      });
      
      // Track changes on change (for select, checkbox, radio)
      form.addEventListener('change', () => {
        trackFormChanges(form);
      });
    }
    
    // ===== Task 4.3: Form Submission Handler =====
    
    /**
     * Handle form submission with loading states and error handling
     * @param {Event} event - The submit event
     */
    async function handleFormSubmit(event) {
      event.preventDefault();
      const form = event.target;
      
      // Validate form
      if (!validateForm(form)) {
        showToast('Please fix the errors in the form', 'error');
        // Focus on first invalid input
        const firstInvalid = form.querySelector('.invalid');
        if (firstInvalid) {
          firstInvalid.focus();
        }
        return;
      }
      
      // Get API endpoint from form data attribute
      const endpoint = form.dataset.api;
      if (!endpoint) {
        console.error('Form missing data-api attribute');
        showToast('Configuration error. Please contact support.', 'error');
        return;
      }
      
      // Get submit button
      const submitBtn = form.querySelector('button[type="submit"]');
      if (!submitBtn) return;
      
      // Show loading state
      setLoadingState(submitBtn, true);
      
      try {
        // Get form data
        const formData = getFormData(form);
        
        // Make API request
        const response = await apiRequest(endpoint, {
          method: 'POST',
          body: JSON.stringify(formData)
        });
        
        // Show success message
        showToast(response.message || 'Configuration saved successfully!', 'success');
        
        // Update initial state to current state
        saveFormInitialState(form);
        trackFormChanges(form);
        
        // Call custom success handler if defined
        if (form.dataset.onSuccess) {
          const handlerName = form.dataset.onSuccess;
          if (typeof window[handlerName] === 'function') {
            window[handlerName](response);
          }
        }
        
      } catch (error) {
        // Error already shown by apiRequest
        console.error('Form submission error:', error);
      } finally {
        // Reset button state
        setLoadingState(submitBtn, false);
      }
    }
    
    /**
     * Setup form submission handler
     * @param {HTMLFormElement} form - The form to setup handler for
     */
    function setupFormSubmission(form) {
      form.addEventListener('submit', handleFormSubmit);
      
      // Prevent default form submission
      form.setAttribute('novalidate', 'true');
      
      // Setup reset button
      const resetBtn = form.querySelector('button[type="reset"]');
      if (resetBtn) {
        resetBtn.addEventListener('click', (e) => {
          e.preventDefault();
          
          // Reset form to initial state
          const formId = form.id;
          const initialState = formInitialStates[formId];
          
          if (initialState) {
            // Restore initial values
            Object.keys(initialState).forEach(key => {
              const input = form.elements[key];
              if (input) {
                if (input.type === 'checkbox') {
                  input.checked = initialState[key];
                } else {
                  input.value = initialState[key];
                }
              }
            });
          } else {
            // Just reset the form
            form.reset();
          }
          
          // Clear validation errors
          clearValidationErrors(form);
          
          // Update change tracking
          trackFormChanges(form);
        });
      }
    }
    
    // ===== Task 4.4: Confirmation Dialogs for Destructive Actions =====
    
    /**
     * Show a confirmation dialog
     * @param {string} title - Dialog title
     * @param {string} message - Dialog message
     * @param {string} confirmText - Confirm button text (default: 'Confirm')
     * @param {string} cancelText - Cancel button text (default: 'Cancel')
     * @param {string} type - Dialog type: 'warning', 'danger' (default: 'warning')
     * @returns {Promise<boolean>} True if confirmed, false if cancelled
     */
    function showConfirmDialog(title, message, confirmText = 'Confirm', cancelText = 'Cancel', type = 'warning') {
      return new Promise((resolve) => {
        // Create dialog overlay
        const overlay = document.createElement('div');
        overlay.className = 'dialog-overlay';
        overlay.setAttribute('role', 'dialog');
        overlay.setAttribute('aria-modal', 'true');
        overlay.setAttribute('aria-labelledby', 'dialog-title');
        overlay.setAttribute('aria-describedby', 'dialog-message');
        
        // Create dialog
        const dialog = document.createElement('div');
        dialog.className = `dialog dialog-${type}`;
        
        const iconMap = {
          warning: '⚠️',
          danger: '🚨'
        };
        const icon = iconMap[type] || iconMap.warning;
        
        dialog.innerHTML = `
          <div class="dialog-header">
            <span class="dialog-icon">${icon}</span>
            <h3 class="dialog-title" id="dialog-title">${title}</h3>
          </div>
          <div class="dialog-body">
            <p class="dialog-message" id="dialog-message">${message}</p>
          </div>
          <div class="dialog-footer">
            <button class="btn btn-secondary dialog-cancel">${cancelText}</button>
            <button class="btn btn-${type === 'danger' ? 'danger' : 'primary'} dialog-confirm">${confirmText}</button>
          </div>
        `;
        
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        // Animate in
        setTimeout(() => overlay.classList.add('show'), 10);
        
        // Focus confirm button
        const confirmBtn = dialog.querySelector('.dialog-confirm');
        setTimeout(() => confirmBtn.focus(), 100);
        
        // Handle confirm
        confirmBtn.addEventListener('click', () => {
          closeDialog(overlay);
          resolve(true);
        });
        
        // Handle cancel
        const cancelBtn = dialog.querySelector('.dialog-cancel');
        cancelBtn.addEventListener('click', () => {
          closeDialog(overlay);
          resolve(false);
        });
        
        // Handle escape key
        const handleEscape = (e) => {
          if (e.key === 'Escape') {
            closeDialog(overlay);
            resolve(false);
            document.removeEventListener('keydown', handleEscape);
          }
        };
        document.addEventListener('keydown', handleEscape);
        
        // Handle overlay click
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) {
            closeDialog(overlay);
            resolve(false);
          }
        });
      });
    }
    
    /**
     * Close a dialog
     * @param {HTMLElement} overlay - The dialog overlay element
     */
    function closeDialog(overlay) {
      overlay.classList.remove('show');
      setTimeout(() => {
        if (overlay.parentNode) {
          overlay.parentNode.removeChild(overlay);
        }
      }, 300);
    }
    
    /**
     * Confirm system restart
     * @returns {Promise<boolean>} True if confirmed
     */
    async function confirmSystemRestart() {
      return await showConfirmDialog(
        'Restart System',
        'Are you sure you want to restart the system? This will temporarily interrupt all services.',
        'Restart',
        'Cancel',
        'warning'
      );
    }
    
    /**
     * Confirm factory reset
     * @returns {Promise<boolean>} True if confirmed
     */
    async function confirmFactoryReset() {
      return await showConfirmDialog(
        'Factory Reset',
        'WARNING: This will erase ALL configuration settings and restart the device. This action cannot be undone. Are you absolutely sure?',
        'Yes, Reset Everything',
        'Cancel',
        'danger'
      );
    }
    
    /**
     * Confirm SIP disconnect
     * @returns {Promise<boolean>} True if confirmed
     */
    async function confirmSIPDisconnect() {
      return await showConfirmDialog(
        'Disconnect SIP',
        'Are you sure you want to disconnect from the SIP server? You will not be able to receive calls until reconnected.',
        'Disconnect',
        'Cancel',
        'warning'
      );
    }
    
    /**
     * Initialize all forms on the page
     */
    function initForms() {
      const forms = document.querySelectorAll('form.config-form');
      
      forms.forEach(form => {
        setupFormValidation(form);
        setupFormChangeTracking(form);
        setupFormSubmission(form);
      });
    }
    
    // ===== Task 5.1: Global Search Index =====
    
    /**
     * Search index containing all searchable settings
     * Each entry includes: label, section, field (element ID), and keywords for matching
     */
    const searchIndex = [
      // Dashboard Section
      { label: 'System Restart', section: 'dashboard', field: 'system-restart-btn', keywords: ['restart', 'reboot', 'system', 'reset'] },
      { label: 'Factory Reset', section: 'dashboard', field: 'factory-reset-btn', keywords: ['factory', 'reset', 'erase', 'default', 'clear'] },
      { label: 'Quick Actions', section: 'dashboard', field: 'quick-actions', keywords: ['actions', 'quick', 'dashboard'] },
      
      // SIP Settings Section
      { label: 'SIP Server', section: 'sip', field: 'sip-server', keywords: ['sip', 'server', 'domain', 'host', 'address', 'voip'] },
      { label: 'SIP Username', section: 'sip', field: 'sip-username', keywords: ['sip', 'username', 'user', 'login', 'account', 'auth'] },
      { label: 'SIP Password', section: 'sip', field: 'sip-password', keywords: ['sip', 'password', 'pass', 'auth', 'authentication', 'credentials'] },
      { label: 'SIP Target 1', section: 'sip', field: 'sip-target1', keywords: ['sip', 'target', 'apartment', 'destination', 'call', 'uri', 'apartment1'] },
      { label: 'SIP Target 2', section: 'sip', field: 'sip-target2', keywords: ['sip', 'target', 'apartment', 'destination', 'call', 'uri', 'apartment2'] },
      { label: 'SIP Connection', section: 'sip', field: 'sip-connection', keywords: ['sip', 'connect', 'disconnect', 'connection', 'register'] },
      { label: 'Test SIP Configuration', section: 'sip', field: 'sip-test', keywords: ['sip', 'test', 'verify', 'check', 'configuration'] },
      
      // Network Settings Section
      { label: 'WiFi SSID', section: 'network', field: 'wifi-ssid', keywords: ['wifi', 'ssid', 'network', 'wireless', 'name'] },
      { label: 'WiFi Password', section: 'network', field: 'wifi-password', keywords: ['wifi', 'password', 'pass', 'wireless', 'key'] },
      { label: 'WiFi Scan', section: 'network', field: 'wifi-scan', keywords: ['wifi', 'scan', 'search', 'networks', 'available'] },
      { label: 'IP Configuration', section: 'network', field: 'ip-config', keywords: ['ip', 'address', 'network', 'configuration', 'dhcp', 'static'] },
      { label: 'DHCP Mode', section: 'network', field: 'dhcp-mode', keywords: ['dhcp', 'automatic', 'dynamic', 'ip', 'mode'] },
      { label: 'Static IP Address', section: 'network', field: 'static-ip', keywords: ['static', 'ip', 'address', 'manual', 'fixed'] },
      { label: 'Subnet Mask', section: 'network', field: 'subnet-mask', keywords: ['subnet', 'mask', 'netmask', 'network'] },
      { label: 'Gateway', section: 'network', field: 'gateway', keywords: ['gateway', 'router', 'default', 'route'] },
      { label: 'DNS Server', section: 'network', field: 'dns-server', keywords: ['dns', 'server', 'nameserver', 'resolver'] },
      { label: 'NTP Server', section: 'network', field: 'ntp-server', keywords: ['ntp', 'time', 'server', 'sync', 'clock'] },
      { label: 'Timezone', section: 'network', field: 'timezone', keywords: ['timezone', 'time', 'zone', 'region', 'location'] },
      { label: 'NTP Sync', section: 'network', field: 'ntp-sync', keywords: ['ntp', 'sync', 'synchronize', 'time', 'update'] },
      
      // Hardware Settings Section
      { label: 'Hardware Information', section: 'hardware', field: 'hardware-info', keywords: ['hardware', 'info', 'chip', 'esp32', 'model', 'specs'] },
      { label: 'Chip Model', section: 'hardware', field: 'chip-model', keywords: ['chip', 'model', 'esp32', 'processor', 'cpu'] },
      { label: 'Flash Size', section: 'hardware', field: 'flash-size', keywords: ['flash', 'storage', 'memory', 'size'] },
      { label: 'Free Heap', section: 'hardware', field: 'free-heap', keywords: ['heap', 'memory', 'ram', 'free', 'available'] },
      { label: 'GPIO Pins', section: 'hardware', field: 'gpio-pins', keywords: ['gpio', 'pins', 'io', 'input', 'output'] },
      { label: 'Doorbell Button', section: 'hardware', field: 'doorbell-button', keywords: ['doorbell', 'button', 'bell', 'input', 'gpio'] },
      { label: 'Door Relay', section: 'hardware', field: 'door-relay', keywords: ['door', 'relay', 'opener', 'output', 'gpio'] },
      { label: 'Light Relay', section: 'hardware', field: 'light-relay', keywords: ['light', 'relay', 'output', 'gpio', 'lamp'] },
      { label: 'DTMF Codes', section: 'hardware', field: 'dtmf-codes', keywords: ['dtmf', 'codes', 'tones', 'commands', 'control'] },
      { label: 'BOOT Button', section: 'hardware', field: 'boot-button', keywords: ['boot', 'button', 'gpio0', 'programming'] },
      
      // Security Settings Section
      { label: 'DTMF PIN', section: 'security', field: 'dtmf-pin', keywords: ['dtmf', 'pin', 'code', 'security', 'password', 'access'] },
      { label: 'PIN Enable', section: 'security', field: 'pin-enable', keywords: ['pin', 'enable', 'security', 'protection', 'dtmf'] },
      { label: 'PIN Timeout', section: 'security', field: 'pin-timeout', keywords: ['pin', 'timeout', 'duration', 'time', 'security'] },
      { label: 'Max PIN Attempts', section: 'security', field: 'max-attempts', keywords: ['pin', 'attempts', 'tries', 'maximum', 'security', 'lockout'] },
      { label: 'Security Configuration', section: 'security', field: 'security-config', keywords: ['security', 'config', 'settings', 'protection'] },
      
      // System Logs Section
      { label: 'SIP Logs', section: 'logs', field: 'sip-logs', keywords: ['sip', 'logs', 'history', 'messages', 'connection'] },
      { label: 'DTMF Logs', section: 'logs', field: 'dtmf-logs', keywords: ['dtmf', 'logs', 'security', 'history', 'events'] },
      { label: 'Log Filter', section: 'logs', field: 'log-filter', keywords: ['log', 'filter', 'search', 'find'] },
      { label: 'Log Export', section: 'logs', field: 'log-export', keywords: ['log', 'export', 'download', 'save'] },
      { label: 'Clear Logs', section: 'logs', field: 'clear-logs', keywords: ['log', 'clear', 'delete', 'remove'] },
      { label: 'Auto Refresh Logs', section: 'logs', field: 'auto-refresh', keywords: ['log', 'auto', 'refresh', 'update', 'automatic'] },
      
      // Hardware Testing Section
      { label: 'Test Doorbell', section: 'testing', field: 'test-doorbell', keywords: ['test', 'doorbell', 'button', 'bell', 'simulate'] },
      { label: 'Test Door Opener', section: 'testing', field: 'test-door', keywords: ['test', 'door', 'opener', 'relay', 'trigger'] },
      { label: 'Test Light', section: 'testing', field: 'test-light', keywords: ['test', 'light', 'relay', 'toggle', 'lamp'] },
      { label: 'Hardware Testing', section: 'testing', field: 'hardware-testing', keywords: ['test', 'hardware', 'testing', 'diagnostic'] },
      
      // Email Reports Section
      { label: 'SMTP Server', section: 'email', field: 'smtp-server', keywords: ['smtp', 'server', 'email', 'mail', 'host'] },
      { label: 'SMTP Port', section: 'email', field: 'smtp-port', keywords: ['smtp', 'port', 'email', 'mail'] },
      { label: 'SMTP Username', section: 'email', field: 'smtp-username', keywords: ['smtp', 'username', 'email', 'mail', 'login'] },
      { label: 'SMTP Password', section: 'email', field: 'smtp-password', keywords: ['smtp', 'password', 'email', 'mail', 'auth'] },
      { label: 'Email Sender', section: 'email', field: 'email-sender', keywords: ['email', 'sender', 'from', 'address'] },
      { label: 'Email Recipient', section: 'email', field: 'email-recipient', keywords: ['email', 'recipient', 'to', 'address', 'destination'] },
      { label: 'Report Schedule', section: 'email', field: 'report-schedule', keywords: ['report', 'schedule', 'frequency', 'daily', 'weekly', 'monthly'] },
      { label: 'Test Email', section: 'email', field: 'test-email', keywords: ['test', 'email', 'send', 'verify'] },
      { label: 'Send Report Now', section: 'email', field: 'send-report', keywords: ['send', 'report', 'email', 'now', 'manual'] },
      
      // OTA Update Section
      { label: 'Firmware Version', section: 'ota', field: 'firmware-version', keywords: ['firmware', 'version', 'build', 'software'] },
      { label: 'OTA Update', section: 'ota', field: 'ota-update', keywords: ['ota', 'update', 'upgrade', 'firmware', 'flash'] },
      { label: 'Upload Firmware', section: 'ota', field: 'upload-firmware', keywords: ['upload', 'firmware', 'file', 'binary', 'bin'] },
      { label: 'Update Progress', section: 'ota', field: 'update-progress', keywords: ['update', 'progress', 'status', 'uploading'] },
      
      // Documentation Section
      { label: 'Quick Start Guide', section: 'docs', field: 'quick-start', keywords: ['quick', 'start', 'guide', 'setup', 'getting started', 'help'] },
      { label: 'Hardware Reference', section: 'docs', field: 'hardware-ref', keywords: ['hardware', 'reference', 'pinout', 'wiring', 'specs'] },
      { label: 'SIP Configuration Guide', section: 'docs', field: 'sip-guide', keywords: ['sip', 'guide', 'configuration', 'setup', 'help'] },
      { label: 'DTMF Commands', section: 'docs', field: 'dtmf-commands', keywords: ['dtmf', 'commands', 'codes', 'reference', 'control'] },
      { label: 'Network Guide', section: 'docs', field: 'network-guide', keywords: ['network', 'guide', 'wifi', 'setup', 'help'] },
      { label: 'API Reference', section: 'docs', field: 'api-reference', keywords: ['api', 'reference', 'endpoints', 'rest', 'integration'] },
      { label: 'Troubleshooting', section: 'docs', field: 'troubleshooting', keywords: ['troubleshooting', 'problems', 'issues', 'help', 'fix'] },
      { label: 'FAQ', section: 'docs', field: 'faq', keywords: ['faq', 'questions', 'answers', 'help'] },
      { label: 'Documentation', section: 'docs', field: 'documentation', keywords: ['documentation', 'docs', 'help', 'manual', 'guide'] }
    ];
    
    // ===== Task 5.2: Implement Search Functionality =====
    
    let selectedSearchResultIndex = -1;
    let currentSearchResults = [];
    
    /**
     * Perform search across all settings
     * @param {string} query - Search query string
     * @returns {Array} Array of matching search results
     */
    function performSearch(query) {
      if (!query || query.trim().length === 0) {
        return [];
      }
      
      const searchText = query.toLowerCase().trim();
      const results = [];
      
      // Search through index
      searchIndex.forEach(item => {
        let score = 0;
        
        // Check label (highest priority)
        if (item.label.toLowerCase().includes(searchText)) {
          score += 10;
        }
        
        // Check keywords
        const matchingKeywords = item.keywords.filter(kw => kw.includes(searchText));
        score += matchingKeywords.length * 5;
        
        // Check section name
        if (item.section.toLowerCase().includes(searchText)) {
          score += 3;
        }
        
        // If any match found, add to results
        if (score > 0) {
          results.push({ ...item, score });
        }
      });
      
      // Sort by score (highest first)
      results.sort((a, b) => b.score - a.score);
      
      // Limit to top 10 results
      return results.slice(0, 10);
    }
    
    /**
     * Display search results in dropdown
     * @param {Array} results - Array of search results
     */
    function displaySearchResults(results) {
      const resultsContainer = document.getElementById('search-results');
      
      if (results.length === 0) {
        resultsContainer.innerHTML = '<div class="search-no-results">No results found</div>';
        resultsContainer.hidden = false;
        return;
      }
      
      resultsContainer.innerHTML = '';
      
      results.forEach((result, index) => {
        const resultElement = document.createElement('div');
        resultElement.className = 'search-result';
        resultElement.setAttribute('role', 'option');
        resultElement.setAttribute('data-index', index);
        resultElement.setAttribute('data-section', result.section);
        resultElement.setAttribute('data-field', result.field);
        
        // Get section display name
        const sectionNames = {
          'dashboard': 'Dashboard',
          'sip': 'SIP Settings',
          'network': 'Network',
          'hardware': 'Hardware',
          'security': 'Security',
          'logs': 'System Logs',
          'testing': 'Hardware Testing',
          'email': 'Email Reports',
          'ota': 'OTA Update',
          'docs': 'Documentation'
        };
        
        resultElement.innerHTML = `
          <span class="result-label">${result.label}</span>
          <span class="result-section">${sectionNames[result.section] || result.section}</span>
        `;
        
        // Click handler
        resultElement.addEventListener('click', () => {
          navigateToSearchResult(result.section, result.field);
          hideSearchResults();
        });
        
        resultsContainer.appendChild(resultElement);
      });
      
      resultsContainer.hidden = false;
      currentSearchResults = results;
      selectedSearchResultIndex = -1;
    }
    
    /**
     * Hide search results dropdown
     */
    function hideSearchResults() {
      const resultsContainer = document.getElementById('search-results');
      resultsContainer.hidden = true;
      resultsContainer.innerHTML = '';
      currentSearchResults = [];
      selectedSearchResultIndex = -1;
    }
    
    /**
     * Select a search result by index
     * @param {number} index - Index of result to select
     */
    function selectSearchResult(index) {
      const resultsContainer = document.getElementById('search-results');
      const resultElements = resultsContainer.querySelectorAll('.search-result');
      
      // Remove previous selection
      resultElements.forEach(el => el.classList.remove('selected'));
      
      // Add selection to new index
      if (index >= 0 && index < resultElements.length) {
        resultElements[index].classList.add('selected');
        resultElements[index].scrollIntoView({ block: 'nearest' });
        selectedSearchResultIndex = index;
      }
    }
    
    /**
     * Initialize global search functionality
     */
    function initGlobalSearch() {
      const searchInput = document.getElementById('global-search');
      if (!searchInput) return;
      
      // Search on input
      searchInput.addEventListener('input', (e) => {
        const query = e.target.value;
        
        if (query.trim().length === 0) {
          hideSearchResults();
          return;
        }
        
        const results = performSearch(query);
        displaySearchResults(results);
      });
      
      // Keyboard navigation in search input
      searchInput.addEventListener('keydown', (e) => {
        const resultsContainer = document.getElementById('search-results');
        
        if (resultsContainer.hidden) {
          // Ctrl+K or / to focus search (handled globally below)
          return;
        }
        
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          const nextIndex = selectedSearchResultIndex + 1;
          if (nextIndex < currentSearchResults.length) {
            selectSearchResult(nextIndex);
          }
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          const prevIndex = selectedSearchResultIndex - 1;
          if (prevIndex >= 0) {
            selectSearchResult(prevIndex);
          }
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (selectedSearchResultIndex >= 0 && selectedSearchResultIndex < currentSearchResults.length) {
            const result = currentSearchResults[selectedSearchResultIndex];
            navigateToSearchResult(result.section, result.field);
            hideSearchResults();
            searchInput.blur();
          }
        } else if (e.key === 'Escape') {
          e.preventDefault();
          hideSearchResults();
          searchInput.blur();
        }
      });
      
      // Close search results when clicking outside
      document.addEventListener('click', (e) => {
        const resultsContainer = document.getElementById('search-results');
        if (!searchInput.contains(e.target) && !resultsContainer.contains(e.target)) {
          hideSearchResults();
        }
      });
      
      // Global keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        // Ctrl+K or / to focus search
        if ((e.ctrlKey && e.key === 'k') || e.key === '/') {
          // Don't trigger if user is typing in an input
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            if (e.key === '/') return; // Allow / in inputs
          }
          
          e.preventDefault();
          searchInput.focus();
          searchInput.select();
        }
        
        // Escape to close search
        if (e.key === 'Escape') {
          const resultsContainer = document.getElementById('search-results');
          if (!resultsContainer.hidden) {
            hideSearchResults();
          }
        }
      });
    }
    
    // ===== Task 5.3: Implement Navigation to Search Results =====
    
    /**
     * Navigate to a search result and highlight the target element
     * @param {string} section - Section ID to navigate to
     * @param {string} field - Field ID to highlight
     */
    function navigateToSearchResult(section, field) {
      // Navigate to the section
      navigateToSection(section);
      
      // Wait for section to render and transition
      setTimeout(() => {
        const element = document.getElementById(field);
        
        if (element) {
          // Scroll element into view
          element.scrollIntoView({ behavior: 'smooth', block: 'center' });
          
          // Add highlight class
          element.classList.add('search-highlight');
          
          // Focus the element if it's focusable
          if (element.tagName === 'INPUT' || 
              element.tagName === 'SELECT' || 
              element.tagName === 'TEXTAREA' || 
              element.tagName === 'BUTTON') {
            element.focus();
          }
          
          // Remove highlight after 2 seconds
          setTimeout(() => {
            element.classList.remove('search-highlight');
          }, 2000);
        } else {
          // If specific field not found, just navigate to section
          console.warn(`Field "${field}" not found in section "${section}"`);
        }
      }, 300);
    }
    
    // ===== Example Action Handlers (demonstrating confirmation dialogs) =====
    
    /**
     * Handle SIP connect action
     */
    async function handleSIPConnect() {
      try {
        showToast('Connecting to SIP server...', 'info');
        const response = await apiRequest('/api/sip/connect', { method: 'POST' });
        showToast(response.message || 'Connected to SIP server successfully!', 'success');
      } catch (error) {
        // Error already shown by apiRequest
      }
    }
    
    /**
     * Handle SIP disconnect action (with confirmation)
     */
    async function handleSIPDisconnect() {
      const confirmed = await confirmSIPDisconnect();
      if (!confirmed) return;
      
      try {
        showToast('Disconnecting from SIP server...', 'info');
        const response = await apiRequest('/api/sip/disconnect', { method: 'POST' });
        showToast(response.message || 'Disconnected from SIP server', 'success');
      } catch (error) {
        // Error already shown by apiRequest
      }
    }
    
    /**
     * Handle SIP test action
     */
    async function handleSIPTest() {
      try {
        showToast('Testing SIP configuration...', 'info');
        const response = await apiRequest('/api/sip/test', { method: 'POST' });
        showToast(response.message || 'SIP configuration test successful!', 'success');
      } catch (error) {
        // Error already shown by apiRequest
      }
    }
    
    /**
     * Handle system restart action (with confirmation)
     */
    async function handleSystemRestart() {
      const confirmed = await confirmSystemRestart();
      if (!confirmed) return;
      
      try {
        showToast('Restarting system...', 'info');
        await apiRequest('/api/system/restart', { method: 'POST' });
        showToast('System is restarting. Page will reload automatically.', 'info', 5000);
        
        // Reload page after delay
        setTimeout(() => {
          window.location.reload();
        }, 5000);
      } catch (error) {
        // Error already shown by apiRequest
      }
    }
    
    /**
     * Handle factory reset action (with confirmation)
     */
    async function handleFactoryReset() {
      const confirmed = await confirmFactoryReset();
      if (!confirmed) return;
      
      try {
        showToast('Performing factory reset...', 'warning');
        await apiRequest('/api/system/factory-reset', { method: 'POST' });
        showToast('Factory reset complete. Device is restarting.', 'info', 5000);
        
        // Reload page after delay
        setTimeout(() => {
          window.location.reload();
        }, 5000);
      } catch (error) {
        // Error already shown by apiRequest
      }
    }
    
    // ===== Task 6: Dashboard Section Functions =====
    
    // ===== Task 6.1: System Information Display =====
    
    /**
     * Update system information display
     */
    async function updateSystemInfo() {
      try {
        const response = await apiRequest('/api/system/status');
        
        // Update uptime
        const uptimeElement = document.getElementById('system-uptime');
        if (uptimeElement && response.uptime !== undefined) {
          uptimeElement.textContent = formatUptime(response.uptime);
        }
        
        // Update free heap
        const heapElement = document.getElementById('system-heap');
        if (heapElement && response.free_heap !== undefined) {
          heapElement.textContent = formatBytes(response.free_heap);
        }
        
        // Update IP address
        const ipElement = document.getElementById('system-ip');
        if (ipElement) {
          // Try to get IP from system status or WiFi status
          const ip = response.ip || response.network?.wifi?.ip || 'N/A';
          ipElement.textContent = ip;
        }
        
        // Update firmware version
        const versionElement = document.getElementById('system-version');
        if (versionElement && response.firmware_version) {
          versionElement.textContent = response.firmware_version;
        }
        
      } catch (error) {
        console.error('Error updating system info:', error);
        // Set error state
        const elements = ['system-uptime', 'system-heap', 'system-ip', 'system-version'];
        elements.forEach(id => {
          const el = document.getElementById(id);
          if (el) el.textContent = 'Error';
        });
      }
    }
    
    /**
     * Format uptime in milliseconds to human-readable string
     * @param {number} uptimeMs - Uptime in milliseconds
     * @returns {string} Formatted uptime string
     */
    function formatUptime(uptimeMs) {
      const seconds = Math.floor(uptimeMs / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);
      
      if (days > 0) {
        return `${days}d ${hours % 24}h ${minutes % 60}m`;
      } else if (hours > 0) {
        return `${hours}h ${minutes % 60}m`;
      } else if (minutes > 0) {
        return `${minutes}m ${seconds % 60}s`;
      } else {
        return `${seconds}s`;
      }
    }
    
    /**
     * Format bytes to human-readable string
     * @param {number} bytes - Number of bytes
     * @returns {string} Formatted bytes string
     */
    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      
      return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
    }
    
    /**
     * Initialize system information display with auto-refresh
     */
    function initSystemInfo() {
      // Initial update
      updateSystemInfo();
      
      // Auto-refresh every 10 seconds
      setInterval(updateSystemInfo, 10000);
    }
    
    // ===== Task 6.3: NTP Sync Status Display =====
    
    /**
     * Update NTP sync status display
     */
    async function updateNTPStatus() {
      try {
        const response = await apiRequest('/api/ntp/status');
        
        const indicatorElement = document.getElementById('ntp-sync-indicator');
        const textElement = document.getElementById('ntp-sync-text');
        const timeElement = document.getElementById('ntp-current-time');
        
        if (response.synced) {
          if (indicatorElement) indicatorElement.textContent = '✅';
          if (textElement) {
            textElement.textContent = 'Synchronized';
            textElement.style.color = 'var(--color-success)';
          }
        } else {
          if (indicatorElement) indicatorElement.textContent = '❌';
          if (textElement) {
            textElement.textContent = 'Not Synchronized';
            textElement.style.color = 'var(--color-danger)';
          }
        }
        
        if (timeElement && response.current_time) {
          timeElement.textContent = response.current_time;
        }
        
      } catch (error) {
        console.error('Error updating NTP status:', error);
        const indicatorElement = document.getElementById('ntp-sync-indicator');
        const textElement = document.getElementById('ntp-sync-text');
        const timeElement = document.getElementById('ntp-current-time');
        
        if (indicatorElement) indicatorElement.textContent = '❌';
        if (textElement) {
          textElement.textContent = 'Error';
          textElement.style.color = 'var(--color-danger)';
        }
        if (timeElement) timeElement.textContent = 'N/A';
      }
    }
    
    /**
     * Initialize NTP status display with auto-refresh
     */
    function initNTPStatus() {
      // Initial update
      updateNTPStatus();
      
      // Auto-refresh every 10 seconds
      setInterval(updateNTPStatus, 10000);
    }
    
    // ===== Task 6.4: Recent Activity Summary =====
    
    /**
     * Update recent activity display
     */
    async function updateRecentActivity() {
      try {
        const response = await apiRequest('/api/sip/log?limit=10');
        
        const activityContainer = document.getElementById('recent-activity');
        if (!activityContainer) return;
        
        if (!response.entries || response.entries.length === 0) {
          activityContainer.innerHTML = '<div style="text-align: center; color: var(--color-text-secondary); padding: var(--spacing-lg);">No recent activity</div>';
          return;
        }
        
        // Build activity list
        let html = '';
        response.entries.forEach(entry => {
          const typeColor = getLogTypeColor(entry.type);
          const timestamp = formatTimestamp(entry.timestamp);
          
          html += `
            <div style="padding: var(--spacing-sm); border-bottom: 1px solid var(--color-border-light); display: flex; gap: var(--spacing-sm); align-items: start;">
              <span style="color: ${typeColor}; font-weight: var(--font-weight-bold); min-width: 60px; font-size: var(--font-size-sm);">${entry.type || 'INFO'}</span>
              <span style="color: var(--color-text-secondary); font-size: var(--font-size-sm); min-width: 80px;">${timestamp}</span>
              <span style="flex: 1; color: var(--color-text); font-size: var(--font-size-sm);">${escapeHtml(entry.message || '')}</span>
            </div>
          `;
        });
        
        activityContainer.innerHTML = html;
        
      } catch (error) {
        console.error('Error updating recent activity:', error);
        const activityContainer = document.getElementById('recent-activity');
        if (activityContainer) {
          activityContainer.innerHTML = '<div style="text-align: center; color: var(--color-danger); padding: var(--spacing-lg);">Error loading activity</div>';
        }
      }
    }
    
    /**
     * Get color for log type
     * @param {string} type - Log type
     * @returns {string} CSS color value
     */
    function getLogTypeColor(type) {
      const typeUpper = (type || '').toUpperCase();
      switch (typeUpper) {
        case 'ERROR':
          return 'var(--color-danger)';
        case 'WARNING':
        case 'WARN':
          return 'var(--color-warning)';
        case 'SUCCESS':
          return 'var(--color-success)';
        case 'INFO':
          return 'var(--color-info)';
        case 'SENT':
          return 'var(--color-primary)';
        case 'RECEIVED':
          return 'var(--color-info)';
        default:
          return 'var(--color-text-secondary)';
      }
    }
    
    /**
     * Format timestamp to readable string
     * @param {number|string} timestamp - Unix timestamp or ISO string
     * @returns {string} Formatted time string
     */
    function formatTimestamp(timestamp) {
      try {
        const date = new Date(timestamp);
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${hours}:${minutes}:${seconds}`;
      } catch (error) {
        return 'N/A';
      }
    }
    
    /**
     * Escape HTML to prevent XSS
     * @param {string} text - Text to escape
     * @returns {string} Escaped text
     */
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    /**
     * Initialize recent activity display with auto-refresh
     */
    function initRecentActivity() {
      // Initial update
      updateRecentActivity();
      
      // Auto-refresh every 10 seconds
      setInterval(updateRecentActivity, 10000);
    }
    
    // ===== Task 6.5: Backup/Restore Functionality =====
    
    /**
     * Handle configuration backup download
     */
    async function handleBackupConfig() {
      try {
        showToast('Generating configuration backup...', 'info');
        
        const includePasswords = document.getElementById('backup-include-passwords')?.checked ?? true;
        
        // Fetch configuration backup
        const response = await apiRequest(`/api/config/backup?include_passwords=${includePasswords}`);
        
        // Create backup object with metadata
        const backup = {
          version: '1.0',
          timestamp: new Date().toISOString(),
          firmware_version: response.firmware_version || 'unknown',
          include_passwords: includePasswords,
          config: response
        };
        
        // Convert to JSON
        const jsonString = JSON.stringify(backup, null, 2);
        
        // Create blob and download
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        // Create download link
        const a = document.createElement('a');
        a.href = url;
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        a.download = `esp32-doorstation-backup-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showToast('Configuration backup downloaded successfully!', 'success');
        
      } catch (error) {
        console.error('Error creating backup:', error);
        // Error already shown by apiRequest
      }
    }
    
    /**
     * Handle restore file selection
     * @param {Event} event - File input change event
     */
    function handleRestoreFileSelected(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      // Validate file type
      if (!file.name.endsWith('.json')) {
        showToast('Please select a valid JSON backup file', 'error');
        event.target.value = '';
        return;
      }
      
      // Read file
      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const jsonString = e.target.result;
          const backup = JSON.parse(jsonString);
          
          // Validate backup format
          if (!backup.config) {
            throw new Error('Invalid backup file format: missing config data');
          }
          
          // Show preview and confirmation
          await showRestorePreview(backup);
          
        } catch (error) {
          console.error('Error reading backup file:', error);
          showToast('Invalid backup file: ' + error.message, 'error');
        }
        
        // Reset file input
        event.target.value = '';
      };
      
      reader.onerror = () => {
        showToast('Error reading file', 'error');
        event.target.value = '';
      };
      
      reader.readAsText(file);
    }
    
    /**
     * Show restore preview dialog
     * @param {Object} backup - Backup object
     */
    async function showRestorePreview(backup) {
      // Create preview message
      let previewHtml = '<div style="margin-bottom: var(--spacing-md);">';
      previewHtml += '<p style="margin-bottom: var(--spacing-sm);"><strong>Backup Information:</strong></p>';
      previewHtml += '<ul style="margin-left: var(--spacing-lg); margin-bottom: var(--spacing-md);">';
      previewHtml += `<li>Created: ${new Date(backup.timestamp).toLocaleString()}</li>`;
      previewHtml += `<li>Firmware Version: ${backup.firmware_version || 'unknown'}</li>`;
      previewHtml += `<li>Includes Passwords: ${backup.include_passwords ? 'Yes' : 'No'}</li>`;
      previewHtml += '</ul>';
      previewHtml += '<p style="color: var(--color-warning);"><strong>Warning:</strong> This will overwrite your current configuration. The device will restart after restore.</p>';
      previewHtml += '</div>';
      
      // Create custom dialog
      const confirmed = await showCustomDialog(
        'Restore Configuration',
        previewHtml,
        'Restore & Restart',
        'Cancel',
        'warning'
      );
      
      if (confirmed) {
        await performRestore(backup);
      }
    }
    
    /**
     * Show custom dialog with HTML content
     * @param {string} title - Dialog title
     * @param {string} htmlContent - HTML content for dialog body
     * @param {string} confirmText - Confirm button text
     * @param {string} cancelText - Cancel button text
     * @param {string} type - Dialog type
     * @returns {Promise<boolean>} True if confirmed
     */
    function showCustomDialog(title, htmlContent, confirmText = 'Confirm', cancelText = 'Cancel', type = 'warning') {
      return new Promise((resolve) => {
        const overlay = document.createElement('div');
        overlay.className = 'dialog-overlay';
        overlay.setAttribute('role', 'dialog');
        overlay.setAttribute('aria-modal', 'true');
        overlay.setAttribute('aria-labelledby', 'dialog-title');
        
        const dialog = document.createElement('div');
        dialog.className = `dialog dialog-${type}`;
        
        const iconMap = {
          warning: '⚠️',
          danger: '🚨',
          info: 'ℹ️'
        };
        const icon = iconMap[type] || iconMap.warning;
        
        dialog.innerHTML = `
          <div class="dialog-header">
            <span class="dialog-icon">${icon}</span>
            <h3 class="dialog-title" id="dialog-title">${title}</h3>
          </div>
          <div class="dialog-body">
            ${htmlContent}
          </div>
          <div class="dialog-footer">
            <button class="btn btn-secondary dialog-cancel">${cancelText}</button>
            <button class="btn btn-${type === 'danger' ? 'danger' : 'primary'} dialog-confirm">${confirmText}</button>
          </div>
        `;
        
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        setTimeout(() => overlay.classList.add('show'), 10);
        
        const confirmBtn = dialog.querySelector('.dialog-confirm');
        setTimeout(() => confirmBtn.focus(), 100);
        
        confirmBtn.addEventListener('click', () => {
          closeDialog(overlay);
          resolve(true);
        });
        
        const cancelBtn = dialog.querySelector('.dialog-cancel');
        cancelBtn.addEventListener('click', () => {
          closeDialog(overlay);
          resolve(false);
        });
        
        const handleEscape = (e) => {
          if (e.key === 'Escape') {
            closeDialog(overlay);
            resolve(false);
            document.removeEventListener('keydown', handleEscape);
          }
        };
        document.addEventListener('keydown', handleEscape);
        
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) {
            closeDialog(overlay);
            resolve(false);
          }
        });
      });
    }
    
    /**
     * Perform configuration restore
     * @param {Object} backup - Backup object
     */
    async function performRestore(backup) {
      try {
        showToast('Restoring configuration...', 'info');
        
        // Send restore request
        const response = await apiRequest('/api/config/restore', {
          method: 'POST',
          body: JSON.stringify({
            config: backup.config,
            include_passwords: backup.include_passwords
          })
        });
        
        showToast('Configuration restored successfully! Device is restarting...', 'success', 5000);
        
        // Reload page after delay
        setTimeout(() => {
          window.location.reload();
        }, 5000);
        
      } catch (error) {
        console.error('Error restoring configuration:', error);
        // Error already shown by apiRequest
      }
    }
    
    /**
     * Initialize Dashboard section
     */
    function initDashboard() {
      initSystemInfo();
      initNTPStatus();
      initRecentActivity();
    }
    
    // ===== Task 7: SIP Settings Section Functions =====
    
    // ===== Task 7.2: Test Call Buttons =====
    
    /**
     * Handle test call to a specific target
     * @param {number} targetNumber - Target number (1 or 2)
     */
    async function handleTestCall(targetNumber) {
      const buttonId = `test-call-target${targetNumber}`;
      const button = document.getElementById(buttonId);
      if (!button) return;
      
      // Get target value from form
      const targetInput = document.getElementById(`sip-target${targetNumber}`);
      if (!targetInput || !targetInput.value) {
        showToast(`Please configure Target ${targetNumber} first`, 'warning');
        return;
      }
      
      const target = targetInput.value;
      
      // Show loading state
      setLoadingState(button, true);
      
      // Show feedback area
      const feedbackDiv = document.getElementById('test-call-feedback');
      const feedbackIcon = document.getElementById('test-call-icon');
      const feedbackMessage = document.getElementById('test-call-message');
      
      if (feedbackDiv) {
        feedbackDiv.style.display = 'block';
        if (feedbackIcon) feedbackIcon.textContent = '⏳';
        if (feedbackMessage) feedbackMessage.textContent = `Initiating test call to ${target}...`;
      }
      
      try {
        showToast(`Initiating test call to Target ${targetNumber}...`, 'info');
        
        const response = await apiRequest('/api/sip/testcall', {
          method: 'POST',
          body: JSON.stringify({ target: target })
        });
        
        // Show success feedback
        if (feedbackIcon) feedbackIcon.textContent = '✅';
        if (feedbackMessage) {
          feedbackMessage.textContent = response.message || `Test call to ${target} initiated successfully!`;
          feedbackMessage.style.color = 'var(--color-success)';
        }
        
        showToast(response.message || `Test call to Target ${targetNumber} successful!`, 'success');
        
      } catch (error) {
        // Show error feedback
        if (feedbackIcon) feedbackIcon.textContent = '❌';
        if (feedbackMessage) {
          feedbackMessage.textContent = error.message || `Test call to ${target} failed`;
          feedbackMessage.style.color = 'var(--color-danger)';
        }
        // Error already shown by apiRequest
      } finally {
        // Reset button state
        setLoadingState(button, false);
        
        // Hide feedback after 5 seconds
        setTimeout(() => {
          if (feedbackDiv) {
            feedbackDiv.style.display = 'none';
          }
        }, 5000);
      }
    }
    
    // ===== Task 7.3: Connection Management =====
    
    /**
     * Update SIP connection status display
     */
    async function updateSIPConnectionStatus() {
      try {
        const response = await apiRequest('/api/sip/status');
        
        const iconElement = document.getElementById('sip-connection-icon');
        const statusElement = document.getElementById('sip-connection-status');
        const connectBtn = document.getElementById('sip-connect-btn');
        const disconnectBtn = document.getElementById('sip-disconnect-btn');
        
        // API returns capitalized status values like "Registered", "Connecting", etc.
        const status = response.status ? response.status.toLowerCase() : '';
        
        if (status === 'registered') {
          if (iconElement) iconElement.textContent = '✅';
          if (statusElement) {
            statusElement.textContent = `Registered (${response.state || 'IDLE'})`;
            statusElement.style.color = 'var(--color-success)';
          }
          // Enable disconnect, disable connect
          if (connectBtn) connectBtn.disabled = true;
          if (disconnectBtn) disconnectBtn.disabled = false;
          
        } else if (status === 'connecting') {
          if (iconElement) iconElement.textContent = '⏳';
          if (statusElement) {
            statusElement.textContent = 'Connecting...';
            statusElement.style.color = 'var(--color-warning)';
          }
          // Disable both buttons while connecting
          if (connectBtn) connectBtn.disabled = true;
          if (disconnectBtn) disconnectBtn.disabled = true;
          
        } else {
          if (iconElement) iconElement.textContent = '❌';
          if (statusElement) {
            statusElement.textContent = response.status || 'Disconnected';
            statusElement.style.color = 'var(--color-danger)';
          }
          // Enable connect, disable disconnect
          if (connectBtn) connectBtn.disabled = false;
          if (disconnectBtn) disconnectBtn.disabled = true;
        }
        
      } catch (error) {
        console.error('Error updating SIP connection status:', error);
        const iconElement = document.getElementById('sip-connection-icon');
        const statusElement = document.getElementById('sip-connection-status');
        const connectBtn = document.getElementById('sip-connect-btn');
        const disconnectBtn = document.getElementById('sip-disconnect-btn');
        
        if (iconElement) iconElement.textContent = '❌';
        if (statusElement) {
          statusElement.textContent = 'Error';
          statusElement.style.color = 'var(--color-danger)';
        }
        // On error, enable connect button, disable disconnect
        if (connectBtn) connectBtn.disabled = false;
        if (disconnectBtn) disconnectBtn.disabled = true;
      }
    }
    
    /**
     * Enhanced SIP connect handler with status update
     */
    async function handleSIPConnectEnhanced() {
      const button = document.getElementById('sip-connect-btn');
      if (button) setLoadingState(button, true);
      
      try {
        showToast('Connecting to SIP server...', 'info');
        const response = await apiRequest('/api/sip/connect', { method: 'POST' });
        showToast(response.message || 'Connected to SIP server successfully!', 'success');
        
        // Update connection status
        await updateSIPConnectionStatus();
        
      } catch (error) {
        // Error already shown by apiRequest
      } finally {
        if (button) setLoadingState(button, false);
      }
    }
    
    /**
     * Enhanced SIP disconnect handler with status update
     */
    async function handleSIPDisconnectEnhanced() {
      const confirmed = await confirmSIPDisconnect();
      if (!confirmed) return;
      
      const button = document.getElementById('sip-disconnect-btn');
      if (button) setLoadingState(button, true);
      
      try {
        showToast('Disconnecting from SIP server...', 'info');
        const response = await apiRequest('/api/sip/disconnect', { method: 'POST' });
        showToast(response.message || 'Disconnected from SIP server', 'success');
        
        // Update connection status
        await updateSIPConnectionStatus();
        
      } catch (error) {
        // Error already shown by apiRequest
      } finally {
        if (button) setLoadingState(button, false);
      }
    }
    
    /**
     * Enhanced SIP test handler with loading state
     */
    async function handleSIPTestEnhanced() {
      const button = document.getElementById('sip-test-btn');
      if (button) setLoadingState(button, true);
      
      try {
        showToast('Testing SIP configuration...', 'info');
        const response = await apiRequest('/api/sip/test', { method: 'POST' });
        showToast(response.message || 'SIP configuration test successful!', 'success');
      } catch (error) {
        // Error already shown by apiRequest
      } finally {
        if (button) setLoadingState(button, false);
      }
    }
    
    // ===== Task 7.4: Load Existing SIP Configuration =====
    
    /**
     * Load SIP configuration from server and populate form
     */
    async function loadSIPConfiguration() {
      try {
        const response = await apiRequest('/api/sip/config');
        
        // Populate form fields
        const serverInput = document.getElementById('sip-server');
        const usernameInput = document.getElementById('sip-username');
        const passwordInput = document.getElementById('sip-password');
        const target1Input = document.getElementById('sip-target1');
        const target2Input = document.getElementById('sip-target2');
        
        if (serverInput && response.server) serverInput.value = response.server;
        if (usernameInput && response.username) usernameInput.value = response.username;
        if (passwordInput && response.password) passwordInput.value = response.password;
        if (target1Input && response.target1) target1Input.value = response.target1;
        if (target2Input && response.target2) target2Input.value = response.target2;
        
        // Save initial state for change tracking
        const form = document.getElementById('sip-form');
        if (form) {
          saveFormInitialState(form);
          trackFormChanges(form);
        }
        
        console.log('SIP configuration loaded successfully');
        
      } catch (error) {
        console.error('Error loading SIP configuration:', error);
        // Don't show error toast on initial load - config might not exist yet
      }
    }
    
    /**
     * Initialize SIP Settings section
     */
    function initSIPSettings() {
      // Load existing configuration
      loadSIPConfiguration();
      
      // Update connection status
      updateSIPConnectionStatus();
      
      // Auto-refresh connection status every 10 seconds
      setInterval(updateSIPConnectionStatus, 10000);
    }
    
    /**
     * Override global SIP handlers to use enhanced versions
     * This ensures the handlers work from both Dashboard and SIP Settings sections
     */
    window.handleSIPConnect = handleSIPConnectEnhanced;
    window.handleSIPDisconnect = handleSIPDisconnectEnhanced;
    window.handleSIPTest = handleSIPTestEnhanced;
    
    // ===== Initialization =====
    
    /**
     * Initialize the application
     */
    function initApp() {
      // Initialize theme
      initTheme();
      
      // Initialize navigation
      initNavigation();
      
      // Initialize status panel
      initStatusPanel();
      
      // Initialize forms
      initForms();
      
      // Initialize global search
      initGlobalSearch();
      
      // Initialize Dashboard section
      initDashboard();
      
      // Initialize SIP Settings section
      initSIPSettings();
      
      // Setup theme toggle
      const themeToggle = document.getElementById('theme-toggle');
      if (themeToggle) {
        themeToggle.addEventListener('click', toggleTheme);
      }
      
      // Setup mobile menu toggle
      const menuToggle = document.querySelector('.menu-toggle');
      if (menuToggle) {
        menuToggle.addEventListener('click', toggleMobileSidebar);
      }
      
      // Close sidebar when clicking outside on mobile
      document.addEventListener('click', (e) => {
        if (window.innerWidth < 768) {
          const sidebar = document.getElementById('sidebar');
          const menuToggle = document.querySelector('.menu-toggle');
          if (sidebar.classList.contains('open') && 
              !sidebar.contains(e.target) && 
              !menuToggle.contains(e.target)) {
            closeMobileSidebar();
          }
        }
      });
      
      // Handle window resize
      window.addEventListener('resize', () => {
        if (window.innerWidth >= 768) {
          const sidebar = document.getElementById('sidebar');
          sidebar.classList.remove('open');
        }
      });
      
      console.log('ESP32 SIP Door Station initialized');
    }
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initApp);
    } else {
      initApp();
    }
  </script>

</body>
</html>
